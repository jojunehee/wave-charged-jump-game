<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <title>Jump Up to the Sky</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Audiowide&display=swap" rel="stylesheet">
  <style>
    html,
    body {
      height: 100%;
      touch-action: none;
    }

    body {
      margin: 0;
      overflow: hidden;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    }

    canvas {
      display: block;
    }

    #score {
      position: absolute;
      top: 10px;
      left: 10px;
      font-size: 24px;
      background: rgba(255, 255, 255, 0.7);
      padding: 6px 10px;
      border-radius: 8px;
      z-index: 10;
      user-select: none;
      display: none;
    }

    #pauseBtn {
      position: absolute;
      top: 10px;
      right: 10px;
      font-size: 24px;
      background: rgba(255, 255, 255, 0.7);
      padding: 6px 12px;
      border-radius: 8px;
      border: none;
      cursor: pointer;
      z-index: 100;
      user-select: none;
      line-height: 1;
      display: none;
    }

    #pauseBtn:hover {
      background: rgba(255, 255, 255, 0.9);
    }

    #chargeBar {
      position: absolute;
      bottom: 10px;
      left: 50%;
      transform: translateX(-50%);
      width: min(80vw, 800px);
      height: 24px;
      background: #333;
      border-radius: 12px;
      overflow: hidden;
      z-index: 11;
      border: 4px solid #222;
      box-shadow: 0 0 10px rgba(0,0,0,0.5);
      display: none;
    }

    #chargeFill {
      height: 100%;
      background: linear-gradient(to right, #ffff00, #ff0000);
      width: 0%;
      transition: width 0.05s linear;
    }

    /* íƒ€ì´í‹€ í™”ë©´ */
    #titleScreen {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      padding-top: 40px;
      box-sizing: border-box;
      z-index: 100;
      color: white;
      text-shadow: 0 0 10px rgba(255, 150, 0, 0.4);
      user-select: none;
      pointer-events: none;
    }

    #titleScreen button {
      pointer-events: auto;
    }

    #gameTitle {
      font-family: 'Audiowide', cursive;
      font-size: min(10vw, 72px);
      font-weight: normal;
      margin-bottom: 40px;
      letter-spacing: 4px;
      text-align: center;
      width: 100%;
      padding: 0 10px;
      box-sizing: border-box;
      animation: float 3s ease-in-out infinite, glow 2s ease-in-out infinite alternate;
    }

    @keyframes float {
      0%, 100% { transform: translateY(0); }
      50% { transform: translateY(-10px); }
    }

    @keyframes glow {
      from { text-shadow: 0 0 10px rgba(255, 150, 0, 0.4); }
      to { text-shadow: 0 0 15px rgba(255, 180, 80, 0.5); }
    }

    #startBtn {
      font-family: 'Audiowide', cursive;
      font-size: 24px;
      padding: 15px 40px;
      background: #ff6600;
      border: none;
      border-radius: 30px;
      color: white;
      cursor: pointer;
      margin-bottom: 20px;
      animation: pulse 1.5s ease-in-out infinite;
      box-shadow: 0 0 20px rgba(255, 150, 0, 0.5), 0 0 40px rgba(255, 100, 0, 0.3);
      text-shadow: 0 0 5px rgba(255, 255, 0, 0.4);
    }

    #infiniteModeBtn {
      font-family: 'Audiowide', cursive;
      font-size: 20px;
      padding: 12px 35px;
      background: #9900ff;
      border: none;
      border-radius: 30px;
      color: white;
      cursor: pointer;
      margin-bottom: 20px;
      box-shadow: 0 0 20px rgba(150, 0, 255, 0.5), 0 0 40px rgba(100, 0, 255, 0.3);
      text-shadow: 0 0 5px rgba(200, 150, 255, 0.4);
    }

    #infiniteModeBtn:hover {
      background: #aa22ff;
    }

    @keyframes pulse {
      0%, 100% { transform: scale(1); opacity: 1; }
      50% { transform: scale(1.05); opacity: 0.9; }
    }

    @keyframes rainbow {
      0% { background-position: 0% 50%; }
      50% { background-position: 100% 50%; }
      100% { background-position: 0% 50%; }
    }

    #startBtn:hover {
      background: #ff7722;
    }

    #controlsBtn, #leaderboardTitleBtn {
      font-size: 16px;
      padding: 10px 20px;
      width: 200px;
      background: rgba(255, 255, 255, 0.15);
      border: 2px solid rgba(255, 255, 255, 0.4);
      border-radius: 20px;
      color: white;
      cursor: pointer;
      margin-bottom: 10px;
    }

    #controlsBtn:hover, #leaderboardTitleBtn:hover {
      background: rgba(255, 255, 255, 0.25);
    }

    #leaderboardTitleBtn {
      margin-bottom: 40px;
    }

    #titleFooter {
      position: absolute;
      bottom: 20px;
      font-size: 14px;
      color: rgba(255, 255, 255, 0.6);
    }

    /* ì¡°ì‘ë²• í™”ë©´ */
    #controlsScreen {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 0, 0, 0.9);
      color: white;
      padding: 30px 40px;
      border-radius: 16px;
      border: 1px solid rgba(255, 255, 255, 0.1);
      z-index: 110;
      display: none;
      max-width: 400px;
      text-align: left;
    }

    #controlsScreen h2 {
      text-align: center;
      margin-top: 0;
      margin-bottom: 20px;
      color: #ff9944;
    }

    #controlsScreen h3 {
      color: #88bbff;
      margin: 15px 0 8px;
    }

    #controlsScreen ul {
      margin: 0;
      padding-left: 20px;
    }

    #controlsScreen li {
      margin: 6px 0;
    }

    #closeControlsBtn {
      display: block;
      margin: 20px auto 0;
      padding: 10px 30px;
      font-size: 14px;
      background: #ff6600;
      border: none;
      border-radius: 20px;
      color: white;
      cursor: pointer;
    }

    /* ë¦¬ë”ë³´ë“œ í™”ë©´ (íƒ€ì´í‹€ì—ì„œ) */
    #leaderboardScreen {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 0, 0, 0.9);
      color: white;
      padding: 30px 40px;
      border-radius: 16px;
      border: 1px solid rgba(255, 255, 255, 0.1);
      z-index: 110;
      display: none;
      min-width: 340px;
      max-width: 400px;
      max-height: 80vh;
      overflow-y: auto;
    }

    #leaderboardScreen h2 {
      text-align: center;
      margin-top: 0;
      margin-bottom: 20px;
      color: #ffd700;
    }

    #leaderboardScreenContent {
      margin-bottom: 15px;
    }

    #leaderboardScreenContent ul {
      padding-left: 0;
      margin: 0;
      list-style: none;
    }

    #closeLeaderboardBtn {
      display: block;
      margin: 20px auto 0;
      padding: 10px 30px;
      font-size: 14px;
      background: #ff6600;
      border: none;
      border-radius: 20px;
      color: white;
      cursor: pointer;
    }

    /* ì¹´ìš´íŠ¸ë‹¤ìš´ */
    #countdown {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-family: 'Audiowide', cursive;
      font-size: min(30vw, 200px);
      font-weight: bold;
      color: white;
      text-shadow: 0 0 15px rgba(255, 150, 0, 0.5);
      z-index: 90;
      display: none;
      animation: countPulse 1s ease-out;
    }

    @keyframes countPulse {
      0% { transform: translate(-50%, -50%) scale(1.5); opacity: 0; }
      50% { opacity: 1; }
      100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
    }

    /* Ready í™”ë©´ */
    #readyScreen {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 85;
      background: rgba(0, 0, 0, 0.3);
    }

    #readyText {
      font-family: 'Audiowide', cursive;
      font-size: min(5vw, 32px);
      color: white;
      text-shadow: 0 0 10px rgba(255, 255, 255, 0.4);
      animation: pulse 1.2s ease-in-out infinite;
      text-align: center;
      user-select: none;
      -webkit-user-select: none;
    }

    /* ì¼ì‹œì •ì§€ í™”ë©´ */
    #pauseScreen {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 0, 0, 0.9);
      color: white;
      padding: 40px 60px;
      border-radius: 16px;
      border: 1px solid rgba(255, 255, 255, 0.1);
      z-index: 80;
      display: none;
      text-align: center;
    }

    #pauseScreen h1 {
      margin-top: 0;
      color: #ff9944;
      font-size: 28px;
    }

    #pauseScreen p {
      color: rgba(255, 255, 255, 0.7);
      margin-bottom: 25px;
    }

    #resumeBtn, #restartBtn, #quitBtn {
      font-size: 14px;
      padding: 12px 30px;
      margin: 8px;
      border: none;
      border-radius: 25px;
      cursor: pointer;
    }

    #resumeBtn {
      background: #ff6600;
      color: white;
      text-shadow: 0 0 5px rgba(255, 255, 0, 0.4);
    }

    #restartBtn {
      background: #4CAF50;
      color: white;
    }

    #quitBtn {
      background: rgba(255, 255, 255, 0.15);
      border: 2px solid rgba(255, 255, 255, 0.3);
      color: white;
    }

    #quitBtn:hover {
      background: rgba(255, 255, 255, 0.25);
    }

    /* ê²Œì„ì˜¤ë²„ í™”ë©´ */
    #gameOverScreen {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 0, 0, 0.9);
      color: white;
      padding: 30px 40px;
      border-radius: 16px;
      border: 1px solid rgba(255, 255, 255, 0.1);
      display: none;
      text-align: center;
      z-index: 70;
      min-width: 320px;
    }

    /* ê²Œì„ í´ë¦¬ì–´ í™”ë©´ */
    #gameClearScreen {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 0, 0, 0.95);
      color: white;
      padding: 40px 50px;
      border-radius: 20px;
      border: 2px solid rgba(255, 215, 0, 0.5);
      display: none;
      text-align: center;
      z-index: 80;
      min-width: 350px;
      box-shadow: 0 0 60px rgba(255, 215, 0, 0.3);
    }

    #gameClearScreen h1 {
      color: #ffd700;
      margin-top: 0;
      font-size: 36px;
      text-shadow: 0 0 20px rgba(255, 215, 0, 0.8);
    }

    #gameClearScreen p {
      font-size: 18px;
      margin: 15px 0;
      color: #ffffcc;
    }

    #gameClearScreen input[type="text"] {
      font-size: 16px;
      padding: 10px 15px;
      border: 2px solid rgba(255, 215, 0, 0.5);
      border-radius: 10px;
      background: rgba(255, 255, 255, 0.1);
      color: white;
      text-align: center;
      width: 200px;
      margin: 10px 0;
    }

    #gameClearScreen button {
      font-size: 14px;
      padding: 12px 25px;
      margin: 8px 5px;
      border: none;
      border-radius: 25px;
      cursor: pointer;
      color: white;
      background: #ffd700;
    }

    #gameOverScreen h1 {
      color: #ff9944;
      margin-top: 0;
      font-size: 28px;
    }

    #gameOverScreen p {
      font-size: 18px;
      margin: 15px 0;
    }

    #gameOverScreen input[type="text"] {
      font-size: 16px;
      padding: 10px 15px;
      border: 2px solid rgba(255, 255, 255, 0.3);
      border-radius: 10px;
      background: rgba(255, 255, 255, 0.1);
      color: white;
      text-align: center;
      width: 200px;
      margin: 10px 0;
    }

    #gameOverScreen input[type="text"]::placeholder {
      color: rgba(255, 255, 255, 0.5);
    }

    #gameOverScreen button {
      font-size: 14px;
      padding: 12px 25px;
      margin: 8px 5px;
      border: none;
      border-radius: 25px;
      cursor: pointer;
      color: white;
    }

    #saveScoreBtn {
      background: #ff6600;
    }

    #playAgainBtn {
      background: #ff6600;
      text-shadow: 0 0 5px rgba(255, 255, 0, 0.4);
    }

    #leaderboardBtn {
      background: rgba(255, 255, 255, 0.15);
      border: 2px solid rgba(255, 255, 255, 0.3);
    }

    #leaderboardBtn:hover {
      background: rgba(255, 255, 255, 0.25);
    }

    #platformLabelsContainer {
      position: absolute;
      top: 0;
      left: 0;
      pointer-events: none;
      z-index: 15;
    }

    .platform-label {
      position: absolute;
      font-size: 20px;
      font-weight: bold;
      color: black;
      text-shadow: 1px 1px white;
      transform: translate(-50%, -50%);
      display: none;
    }
  </style>
</head>

<body>
  <!-- íƒ€ì´í‹€ í™”ë©´ -->
  <div id="titleScreen">
    <div id="gameTitle">JUMP UP TO THE SKY</div>
    <button id="startBtn">â–¶ TAP TO START</button>
    <button id="infiniteModeBtn" style="display:none;">â™¾ï¸ INFINITE MODE</button>
    <button id="controlsBtn">ğŸ® How To Play</button>
    <button id="leaderboardTitleBtn">ğŸ† Leaderboard</button>
    <div id="titleFooter">v3.6 &nbsp;&nbsp;|&nbsp;&nbsp; Â© 2025 ì¡°ì¤€í¬</div>
    <button id="devToggleBtn" style="position:absolute; bottom:10px; right:10px; font-size:10px; padding:5px 8px; background:rgba(255,255,255,0.1); border:1px solid rgba(255,255,255,0.3); color:rgba(255,255,255,0.5); border-radius:5px; cursor:pointer;">DEV: Toggle Unlock</button>
  </div>

  <!-- ë¬´í•œëª¨ë“œ í•´ê¸ˆ íŒì—… -->
  <div id="unlockPopup" style="display:none; position:absolute; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.85); z-index:1000; display:none; justify-content:center; align-items:center;">
    <div style="background:linear-gradient(135deg, #1a1a2e 0%, #16213e 100%); padding:40px; border-radius:20px; text-align:center; max-width:400px; margin:20px; border:2px solid rgba(255,215,0,0.5); box-shadow:0 0 30px rgba(255,215,0,0.3);">
      <div style="font-size:60px; margin-bottom:20px;">ğŸ‰</div>
      <h2 style="color:#ffd700; margin:0 0 15px 0; font-size:24px; text-shadow:0 0 10px rgba(255,215,0,0.5);">ë¬´í•œ ëª¨ë“œ í•´ê¸ˆ!</h2>
      <p style="color:#fff; margin:0 0 20px 0; font-size:16px; line-height:1.6;">
        ì¶•í•˜í•©ë‹ˆë‹¤! ì¼ë°˜ ëª¨ë“œë¥¼ í´ë¦¬ì–´í–ˆìŠµë‹ˆë‹¤!<br><br>
        <span style="color:#aaf;">â™¾ï¸ ë¬´í•œ ëª¨ë“œ</span>ì—ì„œëŠ” í´ë¦¬ì–´ íŒì • ì—†ì´<br>
        ëì—†ì´ ì˜¬ë¼ê°€ë©° ì ìˆ˜ë¥¼ ìŒ“ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤!
      </p>
      <button id="closeUnlockBtn" style="background:linear-gradient(135deg, #ffd700, #ff8c00); color:#000; border:none; padding:12px 40px; border-radius:25px; font-size:16px; font-weight:bold; cursor:pointer;">í™•ì¸</button>
    </div>
  </div>

  <!-- ì¡°ì‘ë²• í™”ë©´ -->
  <div id="controlsScreen">
    <h2>ğŸ® ì¡°ì‘ë²•</h2>
    <h3>ğŸ’» PC</h3>
    <ul>
      <li><strong>SPACE ê¾¹ ëˆ„ë¥´ê¸°</strong>: ì í”„ ì¶©ì „</li>
      <li><strong>SPACE ë–¼ê¸°</strong>: ì í”„!</li>
      <li><strong>A/D</strong> ë˜ëŠ” <strong>â†/â†’</strong>: ê³µì¤‘ ì´ë™</li>
      <li><strong>ESC</strong>: ì¼ì‹œì •ì§€</li>
    </ul>
    <h3>ğŸ“± ëª¨ë°”ì¼</h3>
    <ul>
      <li><strong>í™”ë©´ ê¾¹ ëˆ„ë¥´ê¸°</strong>: ì í”„ ì¶©ì „</li>
      <li><strong>ì† ë–¼ê¸°</strong>: ì í”„!</li>
      <li><strong>ê³µì¤‘ì—ì„œ ë“œë˜ê·¸</strong>: ì¢Œìš° ì´ë™</li>
      <li><strong>â¸ ë²„íŠ¼</strong>: ì¼ì‹œì •ì§€</li>
    </ul>
    <button id="closeControlsBtn">ë‹«ê¸°</button>
  </div>

  <!-- ë¦¬ë”ë³´ë“œ í™”ë©´ (íƒ€ì´í‹€ì—ì„œ) -->
  <div id="leaderboardScreen">
    <h2>ğŸ† Leaderboard</h2>
    <div id="leaderboardScreenContent">
      <p style="color:rgba(255,255,255,0.5);">ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘...</p>
    </div>
    <button id="closeLeaderboardBtn">ë‹«ê¸°</button>
  </div>

  <!-- ì¹´ìš´íŠ¸ë‹¤ìš´ -->
  <div id="countdown"></div>

  <!-- Ready í™”ë©´ (ì¬ì‹œì‘ìš©) -->
  <div id="readyScreen">
    <div id="readyText">Press SPACE or Touch the Screen<br>to Start</div>
  </div>

  <!-- ê²Œì„ UI -->
  <div id="score">Score: 0</div>
  <button id="pauseBtn">â¸</button>
  <div id="chargeBar">
    <div id="chargeFill"></div>
  </div>

  <!-- ì¼ì‹œì •ì§€ í™”ë©´ -->
  <div id="pauseScreen">
    <h1>â¸ ì¼ì‹œì •ì§€</h1>
    <p>ESC ë˜ëŠ” ë²„íŠ¼ì„ ëˆŒëŸ¬ ê³„ì†í•˜ê¸°</p>
    <button id="resumeBtn">â–¶ ê³„ì†í•˜ê¸°</button>
    <button id="restartBtn">ğŸ”„ ë‹¤ì‹œí•˜ê¸°</button>
    <button id="quitBtn">ğŸ  íƒ€ì´í‹€ í™”ë©´ìœ¼ë¡œ</button>
  </div>

  <!-- ê²Œì„ì˜¤ë²„ í™”ë©´ -->
  <div id="gameOverScreen">
    <h1 id="gameOverTitle">Game Over</h1>
    <p id="finalScoreText"></p>

    <div style="margin-top:12px;">
      <input id="playerNameInput" type="text" maxlength="24" placeholder="Your name"
        style="padding:8px;border-radius:6px;border:1px solid #ccc;width:220px;">
      <button id="submitScoreBtn" disabled
        style="padding:8px 12px;border-radius:6px;border:0;background:#4CAF50;color:#fff;cursor:pointer;opacity:0.6;">
        Save Score
      </button>
      <div id="nameHint" style="margin-top:6px;font-size:12px;color:#ffb300;display:none;">
        ì´ë¦„ì´ ì—†ìœ¼ë©´ 'noname'ìœ¼ë¡œ ì €ì¥í• ì§€ í™•ì¸í•©ë‹ˆë‹¤.
      </div>
    </div>

    <div style="margin-top:10px;">
      <button id="playAgainBtn">Play Again</button>
    </div>

    <div id="leaderboard" style="margin-top:18px;text-align:left;max-width:360px;margin-left:auto;margin-right:auto;">
      <h2 style="margin:6px 0 8px;">ğŸ† Leaderboard</h2>
      <ul id="leaderboardList" style="padding-left:0;margin:0;list-style:none;"></ul>
    </div>
  </div>

  <!-- ê²Œì„ í´ë¦¬ì–´ í™”ë©´ -->
  <div id="gameClearScreen">
    <h1>ğŸ‰ GAME CLEAR! ğŸ‰</h1>
    <p id="clearMessage">You reached the event horizon!</p>
    <p id="clearScoreText"></p>
    
    <div style="margin-top:12px;">
      <input id="clearPlayerNameInput" type="text" maxlength="24" placeholder="Your name"
        style="padding:8px;border-radius:6px;border:1px solid #ccc;width:220px;">
      <button id="clearSubmitScoreBtn" disabled
        style="padding:8px 12px;border-radius:6px;border:0;background:#4CAF50;color:#fff;cursor:pointer;opacity:0.6;">
        Save Score
      </button>
    </div>

    <div style="margin-top:10px;">
      <button id="clearToTitleBtn">ğŸ  íƒ€ì´í‹€ í™”ë©´ìœ¼ë¡œ</button>
    </div>
  </div>

  <div id="platformLabelsContainer"></div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>
  <script type="module">
    import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.module.js';

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // Sound Effects (Tone.js)
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    let audioStarted = false;
    const synth = new Tone.Synth().toDestination();
    const jumpSynth = new Tone.Synth().toDestination();
    jumpSynth.volume.value = -12;
    const buttonSynth = new Tone.Synth().toDestination();
    buttonSynth.volume.value = -5;
    const membraneSynth = new Tone.MembraneSynth().toDestination();
    const noiseSynth = new Tone.NoiseSynth({
      noise: { type: 'brown' },
      envelope: { attack: 0.005, decay: 0.1, sustain: 0, release: 0.1 }
    }).toDestination();
    
    let chargeOsc = null;
    let blackholeDrone = null;

    async function startAudio() {
      if (!audioStarted) {
        await Tone.start();
        audioStarted = true;
      }
    }
    
    function startBlackholeDrone() {
      if (!audioStarted || blackholeDrone) return;
      
      // ë ˆì´ì–´ 1: ë‚®ì€ ì›…~ (ë¶€ë“œëŸ¬ìš´ ì €ìŒ) - ì‘ê²Œ ì‹œì‘í•´ì„œ í˜ì´ë“œì¸
      const drone = new Tone.Oscillator({
        frequency: 55,
        type: "sine",
        volume: -60
      }).toDestination();
      
      // ë ˆì´ì–´ 2: íœ˜ì´ì´ (ê³ ì—­ í•„í„° ë…¸ì´ì¦ˆ)
      const wind = new Tone.Noise({
        type: "pink",
        volume: -60
      });
      
      const filter = new Tone.Filter({
        frequency: 800,
        type: "lowpass",
        Q: 1
      }).toDestination();
      
      // ì²œì²œíˆ ì¶œë ì´ëŠ” LFO
      const lfo = new Tone.LFO({
        frequency: 0.08,
        min: 400,
        max: 1000
      }).connect(filter.frequency);
      
      wind.connect(filter);
      
      blackholeDrone = { drone, wind, filter, lfo };
      
      lfo.start();
      drone.start();
      wind.start();
      
      // í˜ì´ë“œì¸ (1.5ì´ˆì— ê±¸ì³ ë¶€ë“œëŸ½ê²Œ)
      drone.volume.rampTo(-20, 1.5);
      wind.volume.rampTo(-25, 1.5);
    }
    
    function updateBlackholeDroneVolume(progress) {
      // progress: 0 (ë“±ì¥) ~ 1 (í´ë¦¬ì–´ ì§ì „)
      if (!blackholeDrone) return;
      
      const { drone, wind } = blackholeDrone;
      // -30dB ~ -15dB (ì‘ê²Œ ì‹œì‘í•´ì„œ ì ì  ì»¤ì§)
      const droneVol = -30 + progress * 15;
      const windVol = -35 + progress * 15;
      
      drone.volume.rampTo(droneVol, 0.3);
      wind.volume.rampTo(windVol, 0.3);
    }
    
    function stopBlackholeDrone() {
      if (blackholeDrone) {
        const { drone, wind, filter, lfo } = blackholeDrone;
        
        // í˜ì´ë“œì•„ì›ƒ (2ì´ˆì— ê±¸ì³ ë¶€ë“œëŸ½ê²Œ)
        drone.volume.rampTo(-60, 2);
        wind.volume.rampTo(-60, 2);
        
        setTimeout(() => {
          lfo.stop();
          lfo.dispose();
          filter.dispose();
          drone.stop();
          drone.dispose();
          wind.stop();
          wind.dispose();
          blackholeDrone = null;
        }, 2000);
      }
    }
    
    // í´ë¦¬ì–´ ì‹œ í„ìŠ¤ + ìˆ˜ì¶• íš¨ê³¼ìŒ
    function playClearPulseSound() {
      if (!audioStarted) return;
      
      // í™¥í™¥ í„ìŠ¤ ì‚¬ìš´ë“œ
      const pulseSynth = new Tone.MembraneSynth({
        pitchDecay: 0.05,
        octaves: 4,
        oscillator: { type: "sine" },
        envelope: { attack: 0.01, decay: 0.3, sustain: 0, release: 0.3 }
      }).toDestination();
      pulseSynth.volume.value = -8;
      
      // 3ë²ˆ í„ìŠ¤
      pulseSynth.triggerAttackRelease("C1", "8n", Tone.now());
      pulseSynth.triggerAttackRelease("C1", "8n", Tone.now() + 0.5);
      pulseSynth.triggerAttackRelease("C1", "8n", Tone.now() + 1.0);
      
      setTimeout(() => pulseSynth.dispose(), 2000);
    }
    
    function playClearCollapseSound() {
      if (!audioStarted) return;
      
      // íŒŒë°”ë°§!!! í­ë°œ
      const impactSynth = new Tone.MembraneSynth({
        pitchDecay: 0.1,
        octaves: 6,
        envelope: { attack: 0.001, decay: 0.5, sustain: 0, release: 0.5 }
      }).toDestination();
      impactSynth.volume.value = -4;
      impactSynth.triggerAttackRelease("G0", "4n");
      
      // ìŠˆìœ ìœ¡ ë¹¨ë ¤ë“œëŠ” ì†Œë¦¬ (í”¼ì¹˜ ë‹¤ìš´)
      const swoosh = new Tone.Oscillator({
        frequency: 800,
        type: "sawtooth",
        volume: -12
      }).toDestination();
      
      swoosh.start();
      swoosh.frequency.rampTo(50, 0.4);
      swoosh.volume.rampTo(-40, 0.5);
      
      setTimeout(() => {
        swoosh.stop();
        swoosh.dispose();
        impactSynth.dispose();
      }, 1000);
    }

    // ë¸”ë™í™€ ì¬ìƒì„± íš¨ê³¼ìŒ
    function playBlackholeExplodeSound() {
      if (!audioStarted) return;
      
      // ê±°ëŒ€í•œ í­ë°œìŒ
      const boom = new Tone.MembraneSynth({
        pitchDecay: 0.3,
        octaves: 8,
        envelope: { attack: 0.001, decay: 1.5, sustain: 0, release: 1 }
      }).toDestination();
      boom.volume.value = 0;
      boom.triggerAttackRelease("C0", "2n");
      
      // ìš°ìš°ìš°ì›… ì”í–¥
      const rumble = new Tone.Oscillator({
        frequency: 30,
        type: "sawtooth",
        volume: -8
      }).toDestination();
      
      rumble.start();
      rumble.frequency.rampTo(60, 0.5);
      rumble.volume.rampTo(-30, 1.5);
      
      setTimeout(() => {
        rumble.stop();
        rumble.dispose();
        boom.dispose();
      }, 2000);
    }

    function startChargeSound() {
      if (!audioStarted) return;
      if (chargeOsc) return;
      chargeOsc = new Tone.Oscillator({
        frequency: 200,
        type: "sine",
        volume: -15
      }).toDestination();
      chargeOsc.start();
    }

    function updateChargeSound(chargeRatio) {
      if (chargeOsc) {
        chargeOsc.frequency.rampTo(200 + chargeRatio * 600, 0.05);
      }
    }

    function stopChargeSound() {
      if (chargeOsc) {
        chargeOsc.stop();
        chargeOsc.dispose();
        chargeOsc = null;
      }
    }

    function playJumpSound() {
      if (!audioStarted) return;
      jumpSynth.triggerAttackRelease("E6", "0.05");
    }

    function playBounceSound() {
      if (!audioStarted) return;
      synth.triggerAttackRelease("G5", "0.1");
    }

    function playSuperBounceSound() {
      if (!audioStarted) return;
      synth.triggerAttackRelease("B5", "0.15");
      setTimeout(() => synth.triggerAttackRelease("E6", "0.1"), 50);
    }

    function playCrumbleSound() {
      if (!audioStarted) return;
      membraneSynth.triggerAttackRelease("C2", "0.2");
    }

    // ìƒˆë¡œìš´ ê· ì—´ ì‚¬ìš´ë“œ - "ì©!" ëŠë‚Œ
    function playCrackSound() {
      if (!audioStarted) return;
      // ë‚ ì¹´ë¡œìš´ í¬ë™ ì‚¬ìš´ë“œ
      noiseSynth.triggerAttackRelease("16n");
      // ë‚®ì€ ì¿µ ì†Œë¦¬ ì¶”ê°€
      membraneSynth.triggerAttackRelease("G1", "0.1");
    }

    function playGameOverSound() {
      if (!audioStarted) return;
      synth.triggerAttackRelease("C3", "0.3");
    }

    function playDeadlySound() {
      if (!audioStarted) return;
      const scream = new Tone.Oscillator({ frequency: 800, type: "sawtooth", volume: -10 }).toDestination();
      scream.start();
      scream.frequency.rampTo(2000, 0.1);
      scream.frequency.rampTo(200, 0.3);
      scream.volume.rampTo(-40, 0.4);
      setTimeout(() => { scream.stop(); scream.dispose(); }, 500);
    }

    function playSaveSound() {
      if (!audioStarted) return;
      synth.triggerAttackRelease("E5", "0.1");
      setTimeout(() => synth.triggerAttackRelease("G5", "0.1"), 100);
    }

    function playCountdownSound() {
      if (!audioStarted) return;
      synth.triggerAttackRelease("C5", "0.1");
    }

    function playStartSound() {
      if (!audioStarted) return;
      synth.triggerAttackRelease("G5", "0.15");
      setTimeout(() => synth.triggerAttackRelease("C6", "0.2"), 100);
    }

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // ê²Œì„ ìƒíƒœ
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    let gameState = 'title'; // 'title', 'countdown', 'ready', 'playing', 'paused', 'gameover'

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // ë°°ê²½ ì„¤ì •
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    const CLEAR_HEIGHT = 100;                    // í´ë¦¬ì–´ ë†’ì´ (ê¸°ì¤€ì !)
    const BLACKHOLE_START_HEIGHT = CLEAR_HEIGHT * 0.6;  // ë¸”ë™í™€ ë“±ì¥ (1500)
    const SKY_NIGHT_HEIGHT = CLEAR_HEIGHT * 0.32;       // ë°¤í•˜ëŠ˜ ì „í™˜ (800)
    const STARS_START_HEIGHT = CLEAR_HEIGHT * 0.16;     // ë³„ ë“±ì¥ (400)
    const CLOUDS_FADE_HEIGHT = SKY_NIGHT_HEIGHT / 2;    // êµ¬ë¦„ ì‚¬ë¼ì§ (400)
    const DIFFICULTY_CENTER = CLEAR_HEIGHT * 0.8;       // ë‚œì´ë„ ê³¡ì„  ì¤‘ì‹¬ (2000)
    const DEATHPLATE_MAX_SPEED_HEIGHT = CLEAR_HEIGHT * 0.8; // ë°ìŠ¤í”Œë ˆì´íŠ¸ ìµœëŒ€ì†ë„ (2000)
    
    // ë¸”ë™í™€ ì• ë‹ˆë©”ì´ì…˜ ê±°ë¦¬ (BLACKHOLE_START_HEIGHT ê¸°ì¤€ ìƒëŒ€ê°’)
    const BH_APPROACH_DISTANCE = (CLEAR_HEIGHT - BLACKHOLE_START_HEIGHT) * 0.5; // Zì¶• ì ‘ê·¼ (500)
    const BH_FADEIN_DISTANCE = 150; // íˆ¬ëª…ë„ í˜ì´ë“œì¸ (ê³ ì •ê°’, ë„ˆë¬´ ê¸¸ë©´ ì–´ìƒ‰)

    const PLATFORM_WEIGHTS = {
      normal: 50,
      narrow: 20,
      bounce: 15,
      vanish: 5,
      crumble: 5,
      superBounce: 4,
      deadly: 0.5
    };

    function getRandomPlatformType() {
      const total = Object.values(PLATFORM_WEIGHTS).reduce((a, b) => a + b, 0);
      let rand = Math.random() * total;
      
      for (const [type, weight] of Object.entries(PLATFORM_WEIGHTS)) {
        rand -= weight;
        if (rand <= 0) return type;
      }
      return 'normal';
    }

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0a0515); // íƒ€ì´í‹€: ìš°ì£¼ìƒ‰

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 5, 10);
    camera.lookAt(0, 0, 0);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    document.body.appendChild(renderer.domElement);

    window.addEventListener('resize', () => {
      const w = window.innerWidth, h = window.innerHeight;
      renderer.setSize(w, h);
      camera.aspect = w / h;
      camera.updateProjectionMatrix();
    });

    const clock = new THREE.Clock();
    let animationId;

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // ë³„ ìƒì„±
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    const starsGeometry = new THREE.BufferGeometry();
    const starCount = 500;
    const starPositions = new Float32Array(starCount * 3);
    
    for (let i = 0; i < starCount; i++) {
      starPositions[i * 3] = (Math.random() - 0.5) * 100;
      starPositions[i * 3 + 1] = Math.random() * 500 + 50;
      starPositions[i * 3 + 2] = -20 - Math.random() * 30;
    }
    
    starsGeometry.setAttribute('position', new THREE.BufferAttribute(starPositions, 3));
    const starsMaterial = new THREE.PointsMaterial({
      color: 0xffffff,
      size: 0.5,
      transparent: true,
      opacity: 1 // íƒ€ì´í‹€ì—ì„œëŠ” ë³´ì„
    });
    const stars = new THREE.Points(starsGeometry, starsMaterial);
    scene.add(stars);

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // êµ¬ë¦„ ìƒì„± (ì—…ê·¸ë ˆì´ë“œ ë²„ì „)
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    const cloudsGroup = new THREE.Group();

    const clouds = [];
    for (let i = 0; i < 20; i++) {
      const cloud = new THREE.Group();
      
      // êµ¬ë¦„ íƒ€ì… ëœë¤ (ê¸¸ì­‰í•œ ê²ƒ, ë­‰íˆ­í•œ ê²ƒ, í° ê²ƒ)
      const cloudType = Math.random();
      let puffCount, spreadX, spreadY, baseSize;
      
      if (cloudType < 0.3) {
        // ê¸¸ì­‰í•œ êµ¬ë¦„
        puffCount = 10 + Math.floor(Math.random() * 6);
        spreadX = 2.0;
        spreadY = 0.5;
        baseSize = 1.2;
      } else if (cloudType < 0.6) {
        // ë­‰ê²Œë­‰ê²Œ í° êµ¬ë¦„
        puffCount = 12 + Math.floor(Math.random() * 8);
        spreadX = 1.5;
        spreadY = 1.0;
        baseSize = 1.8;
      } else {
        // ì‘ê³  ë™ê·¸ë€ êµ¬ë¦„
        puffCount = 6 + Math.floor(Math.random() * 4);
        spreadX = 1.2;
        spreadY = 0.8;
        baseSize = 1.5;
      }
      
      // ì¤‘ì‹¬ë¶€í„° ê°€ì¥ìë¦¬ê¹Œì§€ êµ¬ ë°°ì¹˜
      for (let j = 0; j < puffCount; j++) {
        const angle = (j / puffCount) * Math.PI * 2 + Math.random() * 0.5;
        const distFromCenter = Math.random() * 0.7; // 0 = ì¤‘ì‹¬, 1 = ê°€ì¥ìë¦¬
        
        // ì¤‘ì‹¬ì— ê°€ê¹Œìš¸ìˆ˜ë¡ í¬ê³  ë¶ˆíˆ¬ëª…, ê°€ì¥ìë¦¬ëŠ” ì‘ê³  íˆ¬ëª…
        const sizeMultiplier = 1 - distFromCenter * 0.5;
        const opacityMultiplier = 1 - distFromCenter * 0.6;
        
        const puffSize = baseSize * (0.8 + Math.random() * 0.8) * sizeMultiplier;
        
        const puffMaterial = new THREE.MeshBasicMaterial({
          color: 0xffffff,
          transparent: true,
          opacity: (0.5 + Math.random() * 0.3) * opacityMultiplier
        });
        
        const puff = new THREE.Mesh(
          new THREE.SphereGeometry(puffSize, 12, 12),
          puffMaterial
        );
        
        // ìœ„ì¹˜ - ì¤‘ì‹¬ ì£¼ë³€ìœ¼ë¡œ í¼ì§€ê²Œ
        const radiusX = (puffCount / 4) * spreadX * distFromCenter;
        const radiusZ = (puffCount / 6) * distFromCenter;
        
        puff.position.x = Math.cos(angle) * radiusX + (Math.random() - 0.5) * 1.5;
        puff.position.y = (Math.random() - 0.5) * spreadY * 2 + Math.sin(j * 0.5) * 0.3;
        puff.position.z = Math.sin(angle) * radiusZ + (Math.random() - 0.5);
        
        // ë‚©ì‘í•˜ê²Œ ëˆŒëŸ¬ì„œ êµ¬ë¦„ë‹µê²Œ
        puff.scale.y = 0.4 + Math.random() * 0.3;
        puff.scale.x = 0.9 + Math.random() * 0.3;
        
        cloud.add(puff);
      }
      
      // êµ¬ë¦„ ìœ„ì¹˜
      cloud.position.x = (Math.random() - 0.5) * 50;
      cloud.position.y = i * 25 + Math.random() * 20;
      cloud.position.z = -8 - Math.random() * 10;
      
      // êµ¬ë¦„ ì „ì²´ ìŠ¤ì¼€ì¼ ëœë¤
      const cloudScale = 0.8 + Math.random() * 0.6;
      cloud.scale.setScalar(cloudScale);
      
      cloud.userData = {
        baseY: cloud.position.y,
        baseX: cloud.position.x,
        driftSpeedX: 0.1 + Math.random() * 0.2, // ë°”ëŒì— í˜ëŸ¬ê°€ëŠ” ì†ë„
        driftSpeedY: 0.05 + Math.random() * 0.1, // ìœ„ì•„ë˜ ì‚´ë‘ì‚´ë‘
        driftPhase: Math.random() * Math.PI * 2
      };
      
      clouds.push(cloud);
      cloudsGroup.add(cloud);
    }
    cloudsGroup.visible = false; // íƒ€ì´í‹€ì—ì„œëŠ” ìˆ¨ê¹€
    scene.add(cloudsGroup);

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // íƒœì–‘ (Spriteë¡œ ì™œê³¡ ë°©ì§€)
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    const sunGroup = new THREE.Group();
    
    // 1. ê¸€ë¡œìš° ë ˆì´ì–´ (í° í›„ê´‘) - í°ìƒ‰ ê¸°ë°˜
    const glowCanvas = document.createElement('canvas');
    glowCanvas.width = 256;
    glowCanvas.height = 256;
    const glowCtx = glowCanvas.getContext('2d');
    const glowGradient = glowCtx.createRadialGradient(128, 128, 0, 128, 128, 128);
    glowGradient.addColorStop(0, 'rgba(255, 255, 255, 0.6)');
    glowGradient.addColorStop(0.3, 'rgba(255, 255, 255, 0.3)');
    glowGradient.addColorStop(0.6, 'rgba(255, 255, 255, 0.1)');
    glowGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
    glowCtx.fillStyle = glowGradient;
    glowCtx.fillRect(0, 0, 256, 256);
    
    const glowTexture = new THREE.CanvasTexture(glowCanvas);
    const sunGlowMaterial = new THREE.SpriteMaterial({ 
      map: glowTexture,
      transparent: true,
      blending: THREE.NormalBlending
    });
    const sunGlow = new THREE.Sprite(sunGlowMaterial);
    sunGlow.scale.set(50, 50, 1);
    sunGroup.add(sunGlow);
    
    // 2. ë³¸ì²´ - í°ìƒ‰ ê¸°ë°˜ (colorë¡œ ìƒ‰ ì…í˜)
    const sunCanvas = document.createElement('canvas');
    sunCanvas.width = 128;
    sunCanvas.height = 128;
    const sunCtx = sunCanvas.getContext('2d');
    const sunGradient = sunCtx.createRadialGradient(64, 64, 0, 64, 64, 60);
    sunGradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
    sunGradient.addColorStop(0.5, 'rgba(255, 255, 255, 1)');
    sunGradient.addColorStop(0.85, 'rgba(255, 255, 255, 0.9)');
    sunGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
    sunCtx.fillStyle = sunGradient;
    sunCtx.fillRect(0, 0, 128, 128);
    
    const sunTexture = new THREE.CanvasTexture(sunCanvas);
    const sunMaterial = new THREE.SpriteMaterial({ 
      map: sunTexture,
      transparent: true,
      blending: THREE.NormalBlending
    });
    const sun = new THREE.Sprite(sunMaterial);
    sun.scale.set(20, 20, 1);
    sunGroup.add(sun);
    
    sunGroup.position.set(-60, 30, -60);
    sunGroup.visible = false;
    scene.add(sunGroup);
    
    // íƒœì–‘ í„ìŠ¤ìš© ë³€ìˆ˜
    let sunBaseScale = 20;
    
    // íƒœì–‘ ì—…ë°ì´íŠ¸ í•¨ìˆ˜
    function updateSun(playerHeight, elapsed) {
      // íƒœì–‘ì´ ë³´ì´ëŠ” ë†’ì´ ë²”ìœ„: 0 ~ SKY_NIGHT_HEIGHT
      const sunEndHeight = SKY_NIGHT_HEIGHT;
      
      if (playerHeight >= sunEndHeight) {
        sunGroup.visible = false;
        return;
      }
      
      sunGroup.visible = true;
      
      // progress: 0 (ì‹œì‘) ~ 1 (ë)
      const progress = Math.min(1, playerHeight / sunEndHeight);
      
      // ê°ë„ ê¸°ë°˜ ìœ„ì¹˜ ê³„ì‚°
      // ì‹œì‘: 160ë„, ì •ì˜¤: 90ë„ (ìœ„), ë: 20ë„
      const angle = 160 - progress * 140;
      const radians = angle * Math.PI / 180;
      const radius = 140;
      
      const sunX = Math.cos(radians) * radius;
      const sunYOffset = Math.sin(radians) * radius - 135;
      
      sunGroup.position.x = sunX;
      sunGroup.position.y = camera.position.y + sunYOffset;
      sunGroup.position.z = -60;
      
      // ë¯¸ì„¸í•œ í„ìŠ¤ (ìˆ¨ì‰¬ë“¯ì´)
      const pulse = 1 + Math.sin(elapsed * 2) * 0.03;
      sun.scale.set(sunBaseScale * pulse, sunBaseScale * pulse, 1);
      sunGlow.scale.set(50 * pulse, 50 * pulse, 1);
      
      // ìƒ‰ìƒ ë³€í™”: ì¼ì¶œ(ì£¼í™©) -> ì •ì˜¤(ë°ì€ ë…¸ë‘) -> ì¼ëª°(ì§„í•œ ë¹¨ê°•)
      let r, g, b;
      if (progress < 0.3) {
        // ì¼ì¶œ: ì§„í•œ ì£¼í™© -> ë…¸ë‘
        const p = progress / 0.3;
        r = 1;
        g = 0.4 + p * 0.55; // 0.4 -> 0.95
        b = 0.1 + p * 0.4;  // 0.1 -> 0.5
      } else if (progress < 0.5) {
        // ì •ì˜¤: ë°ì€ ë…¸ë‘
        r = 1;
        g = 0.95;
        b = 0.5;
      } else {
        // ì¼ëª°: ë…¸ë‘ -> ì§„í•œ ë¹¨ê°•/ì£¼í™©
        const p = (progress - 0.5) / 0.5;
        r = 1;
        g = 0.95 - p * 0.75; // 0.95 -> 0.2
        b = 0.5 - p * 0.5;   // 0.5 -> 0
      }
      
      sunMaterial.color.setRGB(r, g, b);
      sunGlowMaterial.color.setRGB(r, g * 0.9, b * 0.7);
    }

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // ë‹¬ (ë°¤í•˜ëŠ˜ì— ë“±ì¥)
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    const moonGroup = new THREE.Group();
    
    // 1. ë‹¬ ê¸€ë¡œìš° (ì€ì€í•œ í›„ê´‘)
    const moonGlowCanvas = document.createElement('canvas');
    moonGlowCanvas.width = 256;
    moonGlowCanvas.height = 256;
    const moonGlowCtx = moonGlowCanvas.getContext('2d');
    const moonGlowGradient = moonGlowCtx.createRadialGradient(128, 128, 0, 128, 128, 128);
    moonGlowGradient.addColorStop(0, 'rgba(200, 220, 255, 0.4)');
    moonGlowGradient.addColorStop(0.3, 'rgba(180, 200, 255, 0.2)');
    moonGlowGradient.addColorStop(0.6, 'rgba(150, 180, 255, 0.08)');
    moonGlowGradient.addColorStop(1, 'rgba(150, 180, 255, 0)');
    moonGlowCtx.fillStyle = moonGlowGradient;
    moonGlowCtx.fillRect(0, 0, 256, 256);
    
    const moonGlowTexture = new THREE.CanvasTexture(moonGlowCanvas);
    const moonGlowMaterial = new THREE.SpriteMaterial({ 
      map: moonGlowTexture,
      transparent: true,
      blending: THREE.AdditiveBlending
    });
    const moonGlow = new THREE.Sprite(moonGlowMaterial);
    moonGlow.scale.set(40, 40, 1);
    moonGroup.add(moonGlow);
    
    // 2. ë‹¬ ë³¸ì²´ (ì•½ê°„ ë…¸ë€ë¹› ë„ëŠ” í°ìƒ‰)
    const moonCanvas = document.createElement('canvas');
    moonCanvas.width = 128;
    moonCanvas.height = 128;
    const moonCtx = moonCanvas.getContext('2d');
    const moonGradient = moonCtx.createRadialGradient(64, 64, 0, 64, 64, 58);
    moonGradient.addColorStop(0, 'rgba(255, 255, 240, 1)');
    moonGradient.addColorStop(0.7, 'rgba(240, 240, 220, 1)');
    moonGradient.addColorStop(0.9, 'rgba(220, 220, 200, 0.9)');
    moonGradient.addColorStop(1, 'rgba(200, 200, 180, 0)');
    moonCtx.fillStyle = moonGradient;
    moonCtx.fillRect(0, 0, 128, 128);
    
    const moonTexture = new THREE.CanvasTexture(moonCanvas);
    const moonMaterial = new THREE.SpriteMaterial({ 
      map: moonTexture,
      transparent: true,
      blending: THREE.NormalBlending
    });
    const moon = new THREE.Sprite(moonMaterial);
    moon.scale.set(15, 15, 1);
    moonGroup.add(moon);
    
    moonGroup.position.set(-60, 30, -60);
    moonGroup.visible = false;
    scene.add(moonGroup);
    
    // ë‹¬ ì—…ë°ì´íŠ¸ í•¨ìˆ˜
    function updateMoon(playerHeight, elapsed) {
      // ë‹¬ì´ ë³´ì´ëŠ” ë†’ì´ ë²”ìœ„: SKY_NIGHT_HEIGHT ~ BLACKHOLE_START_HEIGHT
      const moonStartHeight = SKY_NIGHT_HEIGHT;
      const moonEndHeight = BLACKHOLE_START_HEIGHT;
      
      if (playerHeight < moonStartHeight || playerHeight >= moonEndHeight) {
        moonGroup.visible = false;
        return;
      }
      
      moonGroup.visible = true;
      
      // progress: 0 (ì‹œì‘) ~ 1 (ë)
      const progress = (playerHeight - moonStartHeight) / (moonEndHeight - moonStartHeight);
      
      // íƒœì–‘ê³¼ ê°™ì€ ê¶¤ì 
      const angle = 160 - progress * 140;
      const radians = angle * Math.PI / 180;
      const radius = 140;
      
      const moonX = Math.cos(radians) * radius;
      const moonYOffset = Math.sin(radians) * radius - 135;
      
      moonGroup.position.x = moonX;
      moonGroup.position.y = camera.position.y + moonYOffset;
      moonGroup.position.z = -60;
      
      // ë¯¸ì„¸í•œ í„ìŠ¤
      const pulse = 1 + Math.sin(elapsed * 1.5) * 0.02;
      moon.scale.set(15 * pulse, 15 * pulse, 1);
      moonGlow.scale.set(40 * pulse, 40 * pulse, 1);
    }

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // íƒ€ì´í‹€ìš© ê±°ëŒ€ ë¸”ë™í™€ (ì¸í„°ìŠ¤í…”ë¼ ê°€ë¥´ê°•íŠ€ì•„ ìŠ¤íƒ€ì¼)
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    const titleBlackholeGroup = new THREE.Group();

    // 1. ê²€ì€ ì¤‘ì‹¬ (ì´ë²¤íŠ¸ í˜¸ë¼ì´ì¦Œ) - ì™„ì „í•œ ì–´ë‘ ì˜ êµ¬ì²´
    const titleBhCore = new THREE.Mesh(
      new THREE.SphereGeometry(5, 64, 64),
      new THREE.MeshBasicMaterial({ color: 0x000000 })
    );
    titleBhCore.position.z = -3; // ë’¤ë¡œ ë°€ì–´ì„œ ì•„ë˜ìª½ ì•ˆë³´ì´ê²Œ
    titleBlackholeGroup.add(titleBhCore);

    // 1.5. ê´‘ìêµ¬ (Photon Sphere) - ë¸”ë™í™€ ì£¼ë³€ ë¹›ì˜ ì™œê³¡
    const photonSphereGlow = new THREE.Mesh(
      new THREE.SphereGeometry(5.8, 64, 64),
      new THREE.MeshBasicMaterial({
        color: 0xffffee,
        transparent: true,
        opacity: 0.15,
        side: THREE.BackSide
      })
    );
    titleBlackholeGroup.add(photonSphereGlow);

    // 1.6. ê´‘ìêµ¬ ì™¸ê³½ ê¸€ë¡œìš°
    const photonSphereOuter = new THREE.Mesh(
      new THREE.SphereGeometry(6.5, 64, 64),
      new THREE.MeshBasicMaterial({
        color: 0xffddaa,
        transparent: true,
        opacity: 0.08,
        side: THREE.BackSide
      })
    );
    titleBlackholeGroup.add(photonSphereOuter);

    // 2. ê´‘ìë§ (Photon Ring) - ë¸”ë™í™€ ë°”ë¡œ ë°”ê¹¥ì˜ ë‚ ì¹´ë¡œìš´ ë¹›
    const photonRing = new THREE.Mesh(
      new THREE.TorusGeometry(5.3, 0.08, 16, 100),
      new THREE.MeshBasicMaterial({
        color: 0xffffff,
        transparent: true,
        opacity: 1
      })
    );
    photonRing.rotation.x = Math.PI * 0.48; // ê°•ì°©ì›ë°˜ê³¼ ê°™ì€ ê°ë„
    titleBlackholeGroup.add(photonRing);

    // 3. ê°•ì°©ì›ë°˜ (Accretion Disk) - í‰ë©´ Ring, ì•ˆìª½ ë°ê³  ë‘ê»ê²Œ â†’ ë°”ê¹¥ìª½ í¬ë¯¸í•˜ê²Œ
    const accretionDiskGroup = new THREE.Group();
    
    const diskLayers = [
      { inner: 5.8, outer: 7.5, color: 0xffffff, opacity: 0.95 },
      { inner: 7.5, outer: 10, color: 0xffffcc, opacity: 0.85 },
      { inner: 10, outer: 13, color: 0xffdd66, opacity: 0.7 },
      { inner: 13, outer: 16, color: 0xffaa33, opacity: 0.5 },
      { inner: 16, outer: 20, color: 0xff6600, opacity: 0.3 },
      { inner: 20, outer: 25, color: 0xff4400, opacity: 0.15 },
    ];
    
    diskLayers.forEach(layer => {
      const disk = new THREE.Mesh(
        new THREE.RingGeometry(layer.inner, layer.outer, 128),
        new THREE.MeshBasicMaterial({
          color: layer.color,
          transparent: true,
          opacity: layer.opacity,
          side: THREE.DoubleSide
        })
      );
      accretionDiskGroup.add(disk);
    });
    
    // ê°•ì°©ì›ë°˜ ê¸°ìš¸ì´ê¸° (ê±°ì˜ ì˜†ì—ì„œ ë³´ëŠ” ê°ë„)
    accretionDiskGroup.rotation.x = Math.PI * 0.48;
    titleBlackholeGroup.add(accretionDiskGroup);

    // 6. ì™¸ê³½ ê¸€ë¡œìš° (í¬ë¯¸í•œ ë¹›)
    for (let i = 0; i < 2; i++) {
      const glow = new THREE.Mesh(
        new THREE.RingGeometry(25 + i * 5, 28 + i * 5, 64),
        new THREE.MeshBasicMaterial({
          color: 0xff4400,
          transparent: true,
          opacity: 0.08 - i * 0.03,
          side: THREE.DoubleSide
        })
      );
      glow.rotation.x = Math.PI * 0.48;
      titleBlackholeGroup.add(glow);
    }

    // 7. ë¹¨ë ¤ë“¤ì–´ê°€ëŠ” íŒŒí‹°í´ (ê°•ì°©ì›ë°˜ í‰ë©´ ìœ„)
    const titleParticleCount = 200;
    const titleParticleGeom = new THREE.BufferGeometry();
    const titleParticlePositions = new Float32Array(titleParticleCount * 3);
    const titleParticleAngles = new Float32Array(titleParticleCount);
    const titleParticleRadii = new Float32Array(titleParticleCount);

    for (let i = 0; i < titleParticleCount; i++) {
      titleParticleAngles[i] = Math.random() * Math.PI * 2;
      titleParticleRadii[i] = 6 + Math.random() * 18;
      titleParticlePositions[i * 3] = Math.cos(titleParticleAngles[i]) * titleParticleRadii[i];
      titleParticlePositions[i * 3 + 1] = 0;
      titleParticlePositions[i * 3 + 2] = Math.sin(titleParticleAngles[i]) * titleParticleRadii[i];
    }

    titleParticleGeom.setAttribute('position', new THREE.BufferAttribute(titleParticlePositions, 3));
    const titleParticleMat = new THREE.PointsMaterial({
      color: 0xffdd88,
      size: 0.2,
      transparent: true,
      opacity: 0.8
    });
    const titleBlackholeParticles = new THREE.Points(titleParticleGeom, titleParticleMat);
    titleBlackholeParticles.rotation.x = Math.PI * 0.48;
    titleBlackholeGroup.add(titleBlackholeParticles);

    // 8. ë³„ë¹› ì™œê³¡ (ë¸”ë™í™€ ì£¼ë³€)
    const distortedStarsCount = 60;
    const distortedStarsGeom = new THREE.BufferGeometry();
    const distortedStarsPositions = new Float32Array(distortedStarsCount * 3);
    
    for (let i = 0; i < distortedStarsCount; i++) {
      const angle = Math.random() * Math.PI * 2;
      const radius = 5.5 + Math.random() * 1.5;
      distortedStarsPositions[i * 3] = Math.cos(angle) * radius;
      distortedStarsPositions[i * 3 + 1] = (Math.random() - 0.5) * 3;
      distortedStarsPositions[i * 3 + 2] = Math.sin(angle) * 0.3;
    }
    
    distortedStarsGeom.setAttribute('position', new THREE.BufferAttribute(distortedStarsPositions, 3));
    const distortedStarsMat = new THREE.PointsMaterial({
      color: 0xffffff,
      size: 0.1,
      transparent: true,
      opacity: 0.8
    });
    const distortedStars = new THREE.Points(distortedStarsGeom, distortedStarsMat);
    titleBlackholeGroup.add(distortedStars);

    // ìœ„ì¹˜ ë° í¬ê¸°
    titleBlackholeGroup.position.set(10, 2, -20);
    titleBlackholeGroup.scale.setScalar(1.0);
    titleBlackholeGroup.visible = true;
    scene.add(titleBlackholeGroup);

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // ê²Œì„ìš© ë¸”ë™í™€ (íƒ€ì´í‹€ê³¼ ë™ì¼í•œ ìŠ¤íƒ€ì¼)
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    const blackholeGroup = new THREE.Group();
    blackholeGroup.renderOrder = -1; // ë°œíŒë³´ë‹¤ ë¨¼ì € ë Œë”ë§

    // 1. ì½”ì–´ (ê²€ì€ êµ¬)
    const gameBhCore = new THREE.Mesh(
      new THREE.SphereGeometry(5, 64, 64),
      new THREE.MeshBasicMaterial({ color: 0x000000 })
    );
    blackholeGroup.add(gameBhCore);

    // 1-1. ê´‘ìêµ¬ ê¸€ë¡œìš° (ì½”ì–´ ì£¼ë³€)
    const gamePhotonSphereGlow = new THREE.Mesh(
      new THREE.SphereGeometry(5.15, 64, 64),
      new THREE.MeshBasicMaterial({
        color: 0xffaa44,
        transparent: true,
        opacity: 0.15,
        depthWrite: false
      })
    );
    blackholeGroup.add(gamePhotonSphereGlow);

    // 1-2. ê´‘ìêµ¬ ì™¸ê³½
    const gamePhotonSphereOuter = new THREE.Mesh(
      new THREE.SphereGeometry(5.3, 64, 64),
      new THREE.MeshBasicMaterial({
        color: 0xff6600,
        transparent: true,
        opacity: 0.08,
        depthWrite: false
      })
    );
    blackholeGroup.add(gamePhotonSphereOuter);

    // 2. ê´‘ìë§ (Photon Ring)
    const gamePhotonRing = new THREE.Mesh(
      new THREE.TorusGeometry(5.3, 0.08, 16, 100),
      new THREE.MeshBasicMaterial({
        color: 0xffffff,
        transparent: true,
        opacity: 1,
        depthWrite: false
      })
    );
    gamePhotonRing.rotation.x = Math.PI * 0.48;
    blackholeGroup.add(gamePhotonRing);

    // 3. ê°•ì°©ì›ë°˜ (Accretion Disk)
    const gameAccretionDiskGroup = new THREE.Group();
    
    const gameDiskLayers = [
      { inner: 5.8, outer: 7.5, color: 0xffffff, opacity: 0.95 },
      { inner: 7.5, outer: 10, color: 0xffffcc, opacity: 0.85 },
      { inner: 10, outer: 13, color: 0xffdd66, opacity: 0.7 },
      { inner: 13, outer: 16, color: 0xffaa33, opacity: 0.5 },
      { inner: 16, outer: 20, color: 0xff6600, opacity: 0.3 },
      { inner: 20, outer: 25, color: 0xff4400, opacity: 0.15 },
    ];
    
    gameDiskLayers.forEach(layer => {
      const disk = new THREE.Mesh(
        new THREE.RingGeometry(layer.inner, layer.outer, 128),
        new THREE.MeshBasicMaterial({
          color: layer.color,
          transparent: true,
          opacity: layer.opacity,
          side: THREE.DoubleSide,
          depthWrite: false
        })
      );
      gameAccretionDiskGroup.add(disk);
    });
    
    gameAccretionDiskGroup.rotation.x = Math.PI * 0.48;
    blackholeGroup.add(gameAccretionDiskGroup);

    // 4. ì™¸ê³½ ê¸€ë¡œìš°
    for (let i = 0; i < 2; i++) {
      const glow = new THREE.Mesh(
        new THREE.RingGeometry(25 + i * 5, 28 + i * 5, 64),
        new THREE.MeshBasicMaterial({
          color: 0xff4400,
          transparent: true,
          opacity: 0.08 - i * 0.03,
          side: THREE.DoubleSide,
          depthWrite: false
        })
      );
      glow.rotation.x = Math.PI * 0.48;
      blackholeGroup.add(glow);
    }

    // 5. ë¹¨ë ¤ë“¤ì–´ê°€ëŠ” íŒŒí‹°í´
    const gameParticleCount = 200;
    const gameParticleGeom = new THREE.BufferGeometry();
    const gameParticlePositions = new Float32Array(gameParticleCount * 3);
    const gameParticleAngles = new Float32Array(gameParticleCount);
    const gameParticleRadii = new Float32Array(gameParticleCount);

    for (let i = 0; i < gameParticleCount; i++) {
      gameParticleAngles[i] = Math.random() * Math.PI * 2;
      gameParticleRadii[i] = 6 + Math.random() * 18;
      gameParticlePositions[i * 3] = Math.cos(gameParticleAngles[i]) * gameParticleRadii[i];
      gameParticlePositions[i * 3 + 1] = 0;
      gameParticlePositions[i * 3 + 2] = Math.sin(gameParticleAngles[i]) * gameParticleRadii[i];
    }

    gameParticleGeom.setAttribute('position', new THREE.BufferAttribute(gameParticlePositions, 3));
    const gameParticleMat = new THREE.PointsMaterial({
      color: 0xffdd88,
      size: 0.2,
      transparent: true,
      opacity: 0.8,
      depthWrite: false
    });
    const gameBlackholeParticles = new THREE.Points(gameParticleGeom, gameParticleMat);
    gameAccretionDiskGroup.add(gameBlackholeParticles);

    blackholeGroup.position.set(10, 200, -80); // ì‹œì‘ì€ ë©€ë¦¬
    blackholeGroup.visible = false;
    scene.add(blackholeGroup);

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // ë°°ê²½ ì—…ë°ì´íŠ¸ í•¨ìˆ˜
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    function getBackgroundColor(t) {
      let r, g, b;
      
      if (t < 0.5) {
        // ë§‘ì€ í•˜ëŠ˜ìƒ‰ ìœ ì§€ (ì‚´ì§ë§Œ ë³€í™”)
        const p = t / 0.5;
        r = Math.floor(135 + p * 30);  // 135 -> 165
        g = Math.floor(206 + p * 20);  // 206 -> 226
        b = Math.floor(250 - p * 20);  // 250 -> 230
      } else if (t < 0.65) {
        // í•˜ëŠ˜ìƒ‰ -> ì„ì–‘ (ì£¼í™©/ê³¨ë“œ)
        const p = (t - 0.5) / 0.15;
        r = Math.floor(165 + 90 * p);  // 165 -> 255
        g = Math.floor(226 - 106 * p); // 226 -> 120
        b = Math.floor(230 - 170 * p); // 230 -> 60
      } else if (t < 0.75) {
        // ì„ì–‘ -> ì§„í•œ ë¹¨ê°• (ë¶„í™ ë°©ì§€)
        const p = (t - 0.65) / 0.1;
        r = Math.floor(255 - 75 * p);  // 255 -> 180
        g = Math.floor(120 - 90 * p);  // 120 -> 30
        b = Math.floor(60 - 20 * p);   // 60 -> 40
      } else if (t < 0.88) {
        // ì§„í•œ ë¹¨ê°• -> ë³´ë¼ìƒ‰ ë°¤
        const p = (t - 0.75) / 0.13;
        r = Math.floor(180 - 120 * p); // 180 -> 60
        g = Math.floor(30 - 10 * p);   // 30 -> 20
        b = Math.floor(40 + 140 * p);  // 40 -> 180
      } else {
        // ë³´ë¼ìƒ‰ ë°¤ -> ìš°ì£¼
        const p = (t - 0.88) / 0.12;
        r = Math.floor(60 - 50 * p);   // 60 -> 10
        g = Math.floor(20 - 15 * p);   // 20 -> 5
        b = Math.floor(180 - 140 * p); // 180 -> 40
      }
      
      return { r, g, b };
    }

    function updateBackground(height, elapsed) {
      const t = Math.min(Math.log(1 + height / 200) / Math.log(1 + SKY_NIGHT_HEIGHT / 200), 1);
      const { r, g, b } = getBackgroundColor(t);
      scene.background = new THREE.Color(`rgb(${r},${g},${b})`);
      
      if (height > STARS_START_HEIGHT) {
        const starOpacity = Math.min((height - STARS_START_HEIGHT) / 50, 1);
        starsMaterial.opacity = starOpacity;
        stars.position.y = camera.position.y - 100;
      } else {
        starsMaterial.opacity = 0;
      }
      
      const cloudOpacity = Math.max(0, 1 - (height / CLOUDS_FADE_HEIGHT));
      clouds.forEach(cloud => {
        // ê° puff íˆ¬ëª…ë„ ì¡°ì ˆ
        cloud.children.forEach(puff => {
          const baseOpacity = puff.material.opacity / (puff.userData?.lastCloudOpacity || 1);
          puff.userData = puff.userData || {};
          puff.userData.lastCloudOpacity = cloudOpacity;
          puff.material.opacity = Math.min(0.8, baseOpacity) * cloudOpacity;
        });
        
        // êµ¬ë¦„ ìœ„ì¹˜ ì—…ë°ì´íŠ¸
        const time = clock.getElapsedTime();
        
        // Xì¶•ìœ¼ë¡œ ì²œì²œíˆ í˜ëŸ¬ê°€ê¸° (ë°”ëŒ íš¨ê³¼)
        cloud.position.x = cloud.userData.baseX + Math.sin(time * cloud.userData.driftSpeedX + cloud.userData.driftPhase) * 3;
        
        // Yì¶• - ì¹´ë©”ë¼ ë”°ë¼ê°€ê¸° + ì‚´ë‘ì‚´ë‘
        cloud.position.y = cloud.userData.baseY + camera.position.y * 0.3 + Math.sin(time * cloud.userData.driftSpeedY + cloud.userData.driftPhase) * 0.5;
      });
      cloudsGroup.visible = cloudOpacity > 0;
      
      if (height > BLACKHOLE_START_HEIGHT) {
        blackholeGroup.visible = true;
        
        // ë¸”ë™í™€ ë“œë¡  ì‹œì‘ (í•œë²ˆë§Œ)
        if (!blackholeDrone && audioStarted) {
          startBlackholeDrone();
        }
        
        // ë†’ì´ì— ë”°ë¼ ë“œë¡  ë³¼ë¥¨ ì—…ë°ì´íŠ¸
        const volumeProgress = Math.min((height - BLACKHOLE_START_HEIGHT) / (CLEAR_HEIGHT - BLACKHOLE_START_HEIGHT), 1);
        updateBlackholeDroneVolume(volumeProgress);
        
        // í´ë¦¬ì–´ ì‹œí€€ìŠ¤ ì¤‘ì—ëŠ” ìœ„ì¹˜/íˆ¬ëª…ë„ ì—…ë°ì´íŠ¸ ê±´ë„ˆë›°ê¸°
        if (!isClearSequence) {
          const bhProgress = Math.min((height - BLACKHOLE_START_HEIGHT) / BH_APPROACH_DISTANCE, 1);
          const bhOpacity = Math.min((height - BLACKHOLE_START_HEIGHT) / BH_FADEIN_DISTANCE, 1); // ë¶€ë“œëŸ¬ìš´ í˜ì´ë“œì¸
          
          // Zì¶•: -100ì—ì„œ ì‹œì‘í•´ì„œ -20ê¹Œì§€ ì ì§„ì  ì ‘ê·¼
          const targetZ = -20;
          const startZ = -100;
          blackholeGroup.position.z = startZ + (targetZ - startZ) * bhProgress;
          
          // X, Y ìœ„ì¹˜ (ì›ë°˜ì´ ì¹´ë©”ë¼ ì•„ë˜ë¡œ ê¹”ë¦¬ê²Œ, height(maxY) ê¸°ì¤€ìœ¼ë¡œ ê³ ì •)
          blackholeGroup.position.x = 10;
          blackholeGroup.position.y = height - 5;
          
          // Yì¶• íšŒì „ë§Œ ì¹´ë©”ë¼ ë°©í–¥ìœ¼ë¡œ
          const dx = camera.position.x - blackholeGroup.position.x;
          const dz = camera.position.z - blackholeGroup.position.z;
          blackholeGroup.rotation.y = Math.atan2(dx, dz);
          blackholeGroup.rotation.x = 0.15;
          
          // ì½”ì–´ íˆ¬ëª…ë„ í˜ì´ë“œì¸
          if (gameBhCore && gameBhCore.material) {
            gameBhCore.material.transparent = true;
            gameBhCore.material.opacity = bhOpacity;
          }
          
          // ê´‘ìêµ¬ í˜ì´ë“œì¸
          if (gamePhotonSphereGlow && gamePhotonSphereGlow.material) {
            gamePhotonSphereGlow.material.opacity = (0.12 + Math.sin(elapsed * 2) * 0.06) * bhOpacity;
          }
          if (gamePhotonSphereOuter && gamePhotonSphereOuter.material) {
            gamePhotonSphereOuter.material.opacity = (0.06 + Math.sin(elapsed * 1.5 + 1) * 0.03) * bhOpacity;
          }
          
          // ê´‘ìë§ í˜ì´ë“œì¸
          if (gamePhotonRing && gamePhotonRing.material) {
            gamePhotonRing.material.opacity = (0.9 + Math.sin(elapsed * 4) * 0.1) * bhOpacity;
          }
          
          // ê°•ì°©ì›ë°˜ í˜ì´ë“œì¸ + íšŒì „
          gameAccretionDiskGroup.children.forEach((child, i) => {
            if (child.material && child.type === 'Mesh') {
              const baseOpacities = [0.95, 0.85, 0.7, 0.5, 0.3, 0.15];
              child.material.opacity = (baseOpacities[i] || 0.5) * bhOpacity;
            }
          });
          gameAccretionDiskGroup.rotation.z = elapsed * 0.12;
        
        // íŒŒí‹°í´ ë¹¨ë ¤ë“¤ì–´ê°
        const positions = gameBlackholeParticles.geometry.attributes.position.array;
        for (let i = 0; i < gameParticleCount; i++) {
          gameParticleAngles[i] += 0.02 + (24 - gameParticleRadii[i]) * 0.003;
          gameParticleRadii[i] -= 0.02;
          if (gameParticleRadii[i] < 5.5) {
            gameParticleRadii[i] = 6 + Math.random() * 18;
          }
          positions[i * 3] = Math.cos(gameParticleAngles[i]) * gameParticleRadii[i];
          positions[i * 3 + 1] = 0;
          positions[i * 3 + 2] = Math.sin(gameParticleAngles[i]) * gameParticleRadii[i];
        }
        gameBlackholeParticles.geometry.attributes.position.needsUpdate = true;
        gameParticleMat.opacity = 0.8 * bhOpacity;
        }
      } else {
        blackholeGroup.visible = false;
      }
    }
    
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // ê²Œì„ í´ë¦¬ì–´ ì‹œí€€ìŠ¤
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    let clearSoundPlayed = { pulse: false, collapse: false };
    
    function updateClearSequence(elapsed, delta) {
      const seqTime = elapsed - clearSequenceStart;
      
      // clearTargetPosê°€ ì—†ìœ¼ë©´ ë¦¬í„´
      if (!clearTargetPos) return false;
      
      // 0~2ì´ˆ: ëª¨ë“  ê²ƒì´ ë¸”ë™í™€ë¡œ ë¹¨ë ¤ë“¤ì–´ê° + ì¹´ë©”ë¼ ì§„ë™
      if (seqTime < 2) {
        // í„ìŠ¤ ì‚¬ìš´ë“œ ì‹œì‘ (í•œë²ˆë§Œ)
        if (!clearSoundPlayed.pulse) {
          playClearPulseSound();
          clearSoundPlayed.pulse = true;
        }
        
        const progress = seqTime / 2;
        const easeProgress = Math.pow(progress, 3); // ì²˜ìŒ ëŠë¦¬ê³  ëì— í™• ë¹¨ë ¤ê°
        
        // ë¸”ë™í™€ ì ì  ì»¤ì§ (í„ìŠ¤ ì—†ì´)
        blackholeGroup.scale.setScalar(1 + easeProgress * 0.3);
        
        // ì¹´ë©”ë¼ ì§„ë™ (ì ì  ê°•í•´ì§)
        const shakeIntensity = progress * 0.5;
        camera.position.x = (Math.random() - 0.5) * shakeIntensity;
        
        isCharging = false;
        stopChargeSound();
        chargeBar.style.display = 'none';
        
        // í”Œë ˆì´ì–´: ë¸”ë™í™€ ë°©í–¥ìœ¼ë¡œ ì´ë™ + ì‘ì•„ì§€ë©´ì„œ íˆ¬ëª…í•´ì§
        const playerScale = Math.max(0.01, 1 - easeProgress);
        const pullStrength = easeProgress * 0.15;
        player.position.x += (clearTargetPos.x - player.position.x) * pullStrength;
        player.position.y += (clearTargetPos.y - player.position.y) * pullStrength;
        player.position.z += (clearTargetPos.z - player.position.z) * pullStrength;
        
        player.scale.setScalar(playerScale);
        player.rotation.x += 0.2 * (1 + easeProgress);
        player.rotation.z += 0.15 * (1 + easeProgress);
        // í”Œë ˆì´ì–´ íˆ¬ëª…ë„
        player.traverse(child => {
          if (child.material) {
            child.material.transparent = true;
            child.material.opacity = playerScale;
          }
        });
        
        // ë°œíŒë“¤: ë¸”ë™í™€ ë°©í–¥ìœ¼ë¡œ ì´ë™ + ì‘ì•„ì§€ë©´ì„œ íˆ¬ëª…í•´ì§
        platforms.forEach(p => {
          const scale = Math.max(0.01, 1 - easeProgress);
          const pPull = easeProgress * 0.12;
          p.position.x += (clearTargetPos.x - p.position.x) * pPull;
          p.position.y += (clearTargetPos.y - p.position.y) * pPull;
          p.position.z += (clearTargetPos.z - p.position.z) * pPull;
          p.scale.setScalar(scale);
          p.rotation.x += 0.1;
          p.rotation.z += 0.08;
          // ë°œíŒ íˆ¬ëª…ë„
          p.traverse(child => {
            if (child.material) {
              child.material.transparent = true;
              child.material.opacity = scale;
            }
          });
        });
        
        // ë³„ë“¤ íˆ¬ëª…í•´ì§
        if (starsMaterial) {
          starsMaterial.opacity = Math.max(0, 1 - easeProgress);
        }
        
        return seqTime > 1.5; // 1.5ì´ˆ ì´í›„ë¶€í„° ê²Œì„ ë©ˆì¶¤
      }
      
      // 2~2.5ì´ˆ: ë¸”ë™í™€ í™• ìˆ˜ì¶•
      if (seqTime >= 2 && seqTime < 2.5) {
        // ìˆ˜ì¶• ì‚¬ìš´ë“œ (í•œë²ˆë§Œ)
        if (!clearSoundPlayed.collapse) {
          playClearCollapseSound();
          stopBlackholeDrone();
          clearSoundPlayed.collapse = true;
        }
        
        const collapseProgress = (seqTime - 2) / 0.5;
        
        // ì¹´ë©”ë¼ ê³„ì† ì§„ë™
        const shakeIntensity = 0.5;
        camera.position.x += (Math.random() - 0.5) * shakeIntensity;
        
        // ê¸‰ê²©íˆ ìˆ˜ì¶•
        blackholeGroup.scale.setScalar(Math.max(0.01, 1.3 * Math.pow(1 - collapseProgress, 4)));
        
        player.visible = false;
        
        const brightness = Math.floor(collapseProgress * 255);
        scene.background = new THREE.Color(`rgb(${brightness},${brightness},${brightness})`);
        
        return true;
      }
      
      // 2.5ì´ˆ ì´í›„: í´ë¦¬ì–´ í™”ë©´
      if (seqTime >= 2.5) {
        blackholeGroup.visible = false;
        showClearScreen();
        return true;
      }
      
      return false;
    }
    
    const CLEAR_MESSAGES = [
      "You reached the event horizon!",
      "Absorbed into the singularity...",
      "Beyond the infinite...",
      "One with the cosmos now.",
      "Time stops here.",
      "Welcome to eternity."
    ];

    let clearScreenInitialized = false;
    
    function showClearScreen() {
      gameState = 'clear';
      
      // ë“œë¡  ì •ì§€
      stopBlackholeDrone();
      
      // UI ìˆ¨ê¸°ê¸°
      scoreEl.style.display = 'none';
      chargeBar.style.display = 'none';
      if (pauseBtn) pauseBtn.style.display = 'none';
      
      // ëœë¤ ë¬¸êµ¬ ì„ íƒ
      const clearMsgEl = document.getElementById('clearMessage');
      if (clearMsgEl) {
        clearMsgEl.textContent = CLEAR_MESSAGES[Math.floor(Math.random() * CLEAR_MESSAGES.length)];
      }
      
      // í´ë¦¬ì–´ í™”ë©´ í‘œì‹œ
      const clearScreen = document.getElementById('gameClearScreen');
      const clearScoreText = document.getElementById('clearScoreText');
      clearScoreText.textContent = `Final Score: ${finalScoreValue}`;
      clearScreen.style.display = 'block';
      
      // ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆëŠ” í•œ ë²ˆë§Œ ë“±ë¡
      if (!clearScreenInitialized) {
        clearScreenInitialized = true;
        
        const clearNameInput = document.getElementById('clearPlayerNameInput');
        const clearSubmitBtn = document.getElementById('clearSubmitScoreBtn');
        
        clearNameInput.addEventListener('input', () => {
          clearSubmitBtn.disabled = false;
          clearSubmitBtn.style.opacity = '1';
        });
        
        clearSubmitBtn.addEventListener('click', async () => {
          const name = clearNameInput.value.trim() || 'Champion';
          try {
            await fetch(`${API_BASE}/api/scores`, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ name, score: finalScoreValue })
            });
            clearSubmitBtn.textContent = 'âœ“ Saved!';
            clearSubmitBtn.disabled = true;
          } catch (e) {
            clearSubmitBtn.textContent = 'Error';
          }
        });
        
        // íƒ€ì´í‹€ë¡œ ë²„íŠ¼ (ë¬´í•œëª¨ë“œ í•´ê¸ˆ)
        document.getElementById('clearToTitleBtn').addEventListener('click', () => {
          // ë¬´í•œëª¨ë“œ í•´ê¸ˆ ì €ì¥
          if (!infiniteModeUnlocked) {
            localStorage.setItem('infiniteModeUnlocked', 'true');
            localStorage.setItem('showUnlockPopup', 'true'); // íŒì—… í‘œì‹œ í”Œë˜ê·¸
          }
          location.reload();
        });
      }
    }

    // íƒ€ì´í‹€ ë¸”ë™í™€ ì• ë‹ˆë©”ì´ì…˜ (ì¸í„°ìŠ¤í…”ë¼ ìŠ¤íƒ€ì¼)
    function updateTitleBlackhole(elapsed) {
      // Yì¶• íšŒì „ë§Œ ì¹´ë©”ë¼ ë°©í–¥ìœ¼ë¡œ (ì›ë°˜ ê¸°ìš¸ê¸°ëŠ” ìœ ì§€) - ì¬ìƒì„± ì¤‘ ì œì™¸
      if (!bhRebirthActive) {
        const dx = camera.position.x - titleBlackholeGroup.position.x;
        const dz = camera.position.z - titleBlackholeGroup.position.z;
        titleBlackholeGroup.rotation.y = Math.atan2(dx, dz);
      }
      
      // ê´‘ìêµ¬ í„ìŠ¤
      const photonSphereGlow = titleBlackholeGroup.children[1];
      if (photonSphereGlow && photonSphereGlow.material) {
        photonSphereGlow.material.opacity = 0.12 + Math.sin(elapsed * 2) * 0.06;
      }
      const photonSphereOuter = titleBlackholeGroup.children[2];
      if (photonSphereOuter && photonSphereOuter.material) {
        photonSphereOuter.material.opacity = 0.06 + Math.sin(elapsed * 1.5 + 1) * 0.03;
      }

      // ê°•ì°©ì›ë°˜ ì²œì²œíˆ íšŒì „
      const accretionDiskGroup = titleBlackholeGroup.children.find(c => c.type === 'Group');
      if (accretionDiskGroup) {
        accretionDiskGroup.rotation.z = elapsed * 0.12;
      }

      // ê´‘ìë§ í„ìŠ¤
      const photonRing = titleBlackholeGroup.children[3];
      if (photonRing && photonRing.material) {
        photonRing.material.opacity = 0.9 + Math.sin(elapsed * 4) * 0.1;
      }

      // ì¤‘ë ¥ ë Œì¦ˆ ë¯¸ì„¸í•œ í„ìŠ¤
      titleBlackholeGroup.children.forEach(child => {
        if (child.geometry && child.geometry.type === 'TorusGeometry' && 
            child.geometry.parameters.arc && child.geometry.parameters.arc < Math.PI * 2) {
          child.material.opacity = child.material.opacity * (0.95 + Math.sin(elapsed * 2 + child.position.y * 3) * 0.05);
        }
      });

      // íŒŒí‹°í´ ë¹¨ë ¤ë“¤ì–´ê°
      const particles = titleBlackholeGroup.children.find(c => c.type === 'Points' && c.geometry.attributes.position.count === titleParticleCount);
      if (particles) {
        const positions = particles.geometry.attributes.position.array;
        for (let i = 0; i < titleParticleCount; i++) {
          titleParticleAngles[i] += 0.02 + (24 - titleParticleRadii[i]) * 0.003;
          titleParticleRadii[i] -= 0.02;
          if (titleParticleRadii[i] < 5.5) {
            titleParticleRadii[i] = 6 + Math.random() * 18;
          }
          positions[i * 3] = Math.cos(titleParticleAngles[i]) * titleParticleRadii[i];
          positions[i * 3 + 1] = 0;
          positions[i * 3 + 2] = Math.sin(titleParticleAngles[i]) * titleParticleRadii[i];
        }
        particles.geometry.attributes.position.needsUpdate = true;
      }

      // ì „ì²´ ìŠ¤ì¼€ì¼ ìˆ¨ì‰¬ê¸° (ì¹´ìš´íŠ¸ë‹¤ìš´ ì¤‘ì´ ì•„ë‹ˆê³  ì´ìŠ¤í„°ì—ê·¸/ì¬ìƒì„± ì•„ë‹ ë•Œë§Œ)
      if (gameState !== 'countdown' && !bhEasterEggActive && !bhRebirthActive) {
        const scale = 1.0 + Math.sin(elapsed * 0.3) * 0.03;
        titleBlackholeGroup.scale.setScalar(scale);
      }

      // ì™œê³¡ëœ ë³„ë¹› ë°˜ì§ì„
      const distortedStars = titleBlackholeGroup.children.find(c => c.type === 'Points' && c.geometry.attributes.position.count === 60);
      if (distortedStars) {
        distortedStars.material.opacity = 0.6 + Math.sin(elapsed * 5) * 0.3;
      }
    }

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // UI ìš”ì†Œ
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    const scoreEl = document.getElementById('score');
    const chargeFill = document.getElementById('chargeFill');
    const chargeBar = document.getElementById('chargeBar');
    const finalScoreText = document.getElementById('finalScoreText');
    const gameOverScreen = document.getElementById('gameOverScreen');
    const platformLabelsContainer = document.getElementById('platformLabelsContainer');
    const playerNameInput = document.getElementById('playerNameInput');
    const submitScoreBtn = document.getElementById('submitScoreBtn');
    const playAgainBtn = document.getElementById('playAgainBtn');
    const leaderboardList = document.getElementById('leaderboardList');
    const nameHint = document.getElementById('nameHint');
    const pauseBtn = document.getElementById('pauseBtn');
    const pauseScreen = document.getElementById('pauseScreen');
    const resumeBtn = document.getElementById('resumeBtn');
    const restartBtn = document.getElementById('restartBtn');
    const quitBtn = document.getElementById('quitBtn');
    const titleScreen = document.getElementById('titleScreen');
    const startBtn = document.getElementById('startBtn');
    const infiniteModeBtn = document.getElementById('infiniteModeBtn');
    const controlsBtn = document.getElementById('controlsBtn');
    const controlsScreen = document.getElementById('controlsScreen');
    const closeControlsBtn = document.getElementById('closeControlsBtn');
    const leaderboardTitleBtn = document.getElementById('leaderboardTitleBtn');
    const leaderboardScreen = document.getElementById('leaderboardScreen');
    const leaderboardScreenContent = document.getElementById('leaderboardScreenContent');
    const closeLeaderboardBtn = document.getElementById('closeLeaderboardBtn');
    const countdownEl = document.getElementById('countdown');
    const readyScreen = document.getElementById('readyScreen');
    
    // ë²„íŠ¼ í´ë¦­ íš¨ê³¼ìŒ
    function playButtonSound() {
      if (!audioStarted) return;
      buttonSynth.triggerAttackRelease("G4", "0.05");
    }
    
    // íƒ€ì´í‹€ í™”ë©´ ì²« í´ë¦­ ì‹œ ë¸”ë™í™€ ë“œë¡  ì‹œì‘
    let titleDroneStarted = false;
    async function startTitleDrone() {
      if (titleDroneStarted) return;
      await startAudio();
      startBlackholeDrone();
      titleDroneStarted = true;
    }
    
    titleScreen.addEventListener('click', startTitleDrone);

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // íƒ€ì´í‹€ ë¸”ë™í™€ ì´ìŠ¤í„°ì—ê·¸ (ì½”ì–´ 10ë²ˆ í´ë¦­)
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    let bhCoreClickCount = 0;
    let bhEasterEggActive = false;
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();

    renderer.domElement.addEventListener('click', (event) => {
      if (gameState !== 'title' || bhEasterEggActive) return;
      
      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
      
      raycaster.setFromCamera(mouse, camera);
      const intersects = raycaster.intersectObject(titleBlackholeGroup, true);
      
      // ë¸”ë™í™€ ì½”ì–´ ê·¼ì²˜ í´ë¦­ í™•ì¸
      if (intersects.length > 0) {
        const hitPoint = intersects[0].point;
        const corePos = new THREE.Vector3();
        titleBlackholeGroup.getWorldPosition(corePos);
        const distance = hitPoint.distanceTo(corePos);
        
        if (distance < 8) { // ì½”ì–´ ê·¼ì²˜
          bhCoreClickCount++;
          
          // í´ë¦­í• ìˆ˜ë¡ ë¸”ë™í™€ ì‚´ì§ í„ìŠ¤
          const pulse = 1 + 0.1 * Math.sin(bhCoreClickCount);
          titleBlackholeGroup.scale.setScalar(pulse);
          setTimeout(() => {
            if (!bhEasterEggActive) titleBlackholeGroup.scale.setScalar(1);
          }, 100);
          
          if (bhCoreClickCount >= 10) {
            triggerBhEasterEgg();
          }
        }
      }
    });

    function triggerBhEasterEgg() {
      bhEasterEggActive = true;
      
      const startTime = performance.now();
      const suckDuration = 2000;
      const collapseDuration = 500;
      
      // ë¸”ë™í™€ ì›”ë“œ ìœ„ì¹˜ ì €ì¥
      const bhWorldPos = new THREE.Vector3();
      titleBlackholeGroup.getWorldPosition(bhWorldPos);
      
      // íƒ€ì´í‹€ í™”ë©´ì„ ìº”ë²„ìŠ¤ ìœ„ì¹˜ ê¸°ì¤€ìœ¼ë¡œ ë¹¨ì•„ë“¤ì´ê¸° ìœ„í•œ ì¤‘ì‹¬ì 
      const bhScreenPos = bhWorldPos.clone().project(camera);
      const bhScreenX = (bhScreenPos.x + 1) / 2 * window.innerWidth;
      const bhScreenY = (-bhScreenPos.y + 1) / 2 * window.innerHeight;
      
      // ë¹¨ë ¤ë“¤ì–´ê°ˆ ìš”ì†Œë“¤
      const gameTitle = document.getElementById('gameTitle');
      const subtitleP = document.querySelector('#titleScreen p');
      const titleFooter = document.getElementById('titleFooter');
      const allButtons = [startBtn, infiniteModeBtn, controlsBtn, leaderboardTitleBtn];
      const allElements = [gameTitle, subtitleP, titleFooter, ...allButtons].filter(el => el);
      
      // ì´ˆê¸° ìœ„ì¹˜ ì €ì¥ (ì¤‘ì‹¬ ê¸°ì¤€)
      const elementsData = [];
      allElements.forEach(el => {
        if (el && el.style.display !== 'none') {
          const rect = el.getBoundingClientRect();
          if (rect.width > 0 && rect.height > 0) {
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;
            // ê¸°ì¡´ ì• ë‹ˆë©”ì´ì…˜ ì €ì¥ í›„ ë„ê¸°
            const computedStyle = getComputedStyle(el);
            const originalAnimation = computedStyle.animation;
            el.style.setProperty('animation', 'none', 'important');
            elementsData.push({
              el,
              centerX,
              centerY,
              width: rect.width,
              height: rect.height,
              originalAnimation
            });
          }
        }
      });
      
      function animateEasterEgg() {
        const elapsed = performance.now() - startTime;
        
        if (elapsed < suckDuration) {
          // ë¹¨ë ¤ë“¤ì–´ê°€ëŠ” ë‹¨ê³„
          const progress = elapsed / suckDuration;
          // ë” ê·¹ì ì¸ ê°€ì† (ì²˜ìŒ ëŠë¦¬ê³  ëì— í™• ë¹¨ë ¤ê°)
          const easeProgress = Math.pow(progress, 3);
          
          // ë¸”ë™í™€ ì ì  ì»¤ì§ (í„ìŠ¤ ì—†ì´)
          const scale = 1 + easeProgress * 0.3;
          titleBlackholeGroup.scale.setScalar(scale);
          
          // UI ìš”ì†Œë“¤ ë¸”ë™í™€ë¡œ ë¹¨ë ¤ë“¤ì–´ê° + ë–¨ë¦¼
          elementsData.forEach(data => {
            const dx = bhScreenX - data.centerX;
            const dy = bhScreenY - data.centerY;
            const moveX = dx * easeProgress;
            const moveY = dy * easeProgress;
            const scale = Math.max(0.01, 1 - easeProgress);
            
            // ë–¨ë¦¼ íš¨ê³¼ (progressì— ë¹„ë¡€í•´ì„œ ì ì  ê°•í•´ì§)
            const shakeIntensity = progress * 8;
            const shakeX = (Math.random() - 0.5) * shakeIntensity;
            const shakeY = (Math.random() - 0.5) * shakeIntensity;
            
            data.el.style.transform = `translate(${moveX + shakeX}px, ${moveY + shakeY}px) scale(${scale})`;
            data.el.style.opacity = scale;
          });
          
          // ë³„ë“¤ë„ ë¹¨ë ¤ë“¤ì–´ê°
          const starPositions = starsGeometry.attributes.position.array;
          for (let i = 0; i < starCount; i++) {
            starPositions[i * 3] *= (1 - easeProgress * 0.02);
            starPositions[i * 3 + 1] *= (1 - easeProgress * 0.02);
          }
          starsGeometry.attributes.position.needsUpdate = true;
          
          // ì¹´ë©”ë¼ë„ í”ë“¤ë¦¼ (ì ì  ê°•í•´ì§)
          const camShake = progress * 0.5;
          camera.position.x = (Math.random() - 0.5) * camShake;
          camera.position.y = 5 + (Math.random() - 0.5) * camShake;
          
          requestAnimationFrame(animateEasterEgg);
        } else if (elapsed < suckDuration + collapseDuration) {
          // ìˆ˜ì¶• ë‹¨ê³„ (0.5ì´ˆë§Œì— í™• ìˆ˜ì¶•!)
          const collapseProgress = (elapsed - suckDuration) / collapseDuration;
          
          // ì¹´ë©”ë¼ ê³„ì† í”ë“¤ë¦¼
          const camShake = 0.5;
          camera.position.x = (Math.random() - 0.5) * camShake;
          camera.position.y = 5 + (Math.random() - 0.5) * camShake;
          
          // UI ì™„ì „íˆ ìˆ¨ê¹€
          elementsData.forEach(data => {
            data.el.style.opacity = '0';
          });
          
          // ë¸”ë™í™€ í™• ìˆ˜ì¶• (ê¸‰ê²©íˆ ìˆ˜ì¶•)
          const collapseScale = Math.max(0.001, 1.3 * Math.pow(1 - collapseProgress, 4));
          titleBlackholeGroup.scale.setScalar(collapseScale);
          
          // ë²ˆì©! (ë§ˆì§€ë§‰ì— ë°ì•„ì§)
          if (collapseProgress > 0.85) {
            const flashIntensity = (collapseProgress - 0.85) / 0.15;
            const c = Math.floor(flashIntensity * 255);
            scene.background = new THREE.Color(`rgb(${c},${c},${c})`);
          }
          
          requestAnimationFrame(animateEasterEgg);
        } else {
          // ì™„ë£Œ - ë¦¬ì…‹
          playClearCollapseSound();
          
          // í™”ë©´ ì•”ì „
          scene.background = new THREE.Color(0x000000);
          titleBlackholeGroup.visible = false;
          
          setTimeout(() => {
            // ëª¨ë“  ê²ƒ ë¦¬ì…‹
            bhEasterEggActive = false;
            bhCoreClickCount = 0;
            
            // ì¹´ë©”ë¼ ë¦¬ì…‹
            camera.position.set(0, 5, 10);
            
            // UI ë¦¬ì…‹
            elementsData.forEach(data => {
              data.el.style.transform = '';
              data.el.style.opacity = '';
              data.el.style.removeProperty('animation');
            });
            
            // ë³„ ë¦¬ì…‹
            for (let i = 0; i < starCount; i++) {
              starsGeometry.attributes.position.array[i * 3] = (Math.random() - 0.5) * 100;
              starsGeometry.attributes.position.array[i * 3 + 1] = Math.random() * 500 + 50;
              starsGeometry.attributes.position.array[i * 3 + 2] = -20 - Math.random() * 30;
            }
            starsGeometry.attributes.position.needsUpdate = true;
            
            // ë°°ê²½ìƒ‰ í˜ì´ë“œì¸
            scene.background = new THREE.Color(0x0a0515);
            
            // íƒ€ì´í‹€ í™”ë©´ í˜ì´ë“œì¸
            titleScreen.style.opacity = '0';
            setTimeout(() => {
              titleScreen.style.transition = 'opacity 1s ease-in';
              titleScreen.style.opacity = '1';
              setTimeout(() => {
                titleScreen.style.transition = '';
              }, 1000);
            }, 100);
            
            // ë¸”ë™í™€ì€ 10ì´ˆ í›„ ì¬ìƒì„±
            setTimeout(() => {
              startBlackholeRebirth();
            }, 10000);
            
          }, 300);
        }
      }
      
      animateEasterEgg();
    }

    // ë¸”ë™í™€ ì¬ìƒì„± ì• ë‹ˆë©”ì´ì…˜ (íŒ½ì°½)
    let bhRebirthActive = false;
    
    function startBlackholeRebirth() {
      const expandDuration = 800;   // íŒ½ì°½ ì‹œê°„
      const settleDuration = 1500;  // ì•ˆì •í™” ì‹œê°„
      const overshoot = 1.15;       // ì˜¤ë²„ìŠˆíŠ¸ í¬ê¸° (15% ë” í¼)
      
      bhRebirthActive = true;
      
      // ë¸”ë™í™€ ì´ˆê¸° ìƒíƒœ: ì•„ì£¼ ì‘ê²Œ
      titleBlackholeGroup.visible = true;
      titleBlackholeGroup.scale.setScalar(0.001);
      
      // íš¨ê³¼ìŒ
      playBlackholeExplodeSound();
      
      const startTime = performance.now();
      
      function animateRebirth() {
        const elapsed = performance.now() - startTime;
        const globalElapsed = performance.now() / 1000; // ìˆ¨ì‰¬ê¸° ê³„ì‚°ìš©
        const breathScale = 1.0 + Math.sin(globalElapsed * 0.3) * 0.03; // í˜„ì¬ ìˆ¨ì‰¬ê¸° ìŠ¤ì¼€ì¼
        
        if (elapsed < expandDuration) {
          // 1ë‹¨ê³„: ë¹ ë¥´ê²Œ íŒ½ì°½ (ì˜¤ë²„ìŠˆíŠ¸ê¹Œì§€)
          const progress = elapsed / expandDuration;
          const expandScale = Math.pow(progress, 0.25) * overshoot;
          titleBlackholeGroup.scale.setScalar(Math.max(0.001, expandScale));
          
          requestAnimationFrame(animateRebirth);
        } else if (elapsed < expandDuration + settleDuration) {
          // 2ë‹¨ê³„: ì²œì²œíˆ í˜„ì¬ ìˆ¨ì‰¬ê¸° ìŠ¤ì¼€ì¼ë¡œ
          const progress = (elapsed - expandDuration) / settleDuration;
          const scale = overshoot - (overshoot - breathScale) * progress;
          titleBlackholeGroup.scale.setScalar(scale);
          
          requestAnimationFrame(animateRebirth);
        } else {
          // ì™„ë£Œ - ìˆ¨ì‰¬ê¸° ì• ë‹ˆë©”ì´ì…˜ì´ ìì—°ìŠ¤ëŸ½ê²Œ ì´ì–´ë°›ìŒ
          bhRebirthActive = false;
        }
      }
      
      animateRebirth();
    }

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // ì„œë²„ API ì—°ê²°
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    const API_BASE =
      (location.hostname === 'localhost' || location.hostname === '127.0.0.1')
        ? 'http://localhost:8080'
        : 'https://wave-charged-jump-game.onrender.com';

    setInterval(async () => {
      try {
        await fetch(`${API_BASE}/api/scores/top?limit=1`);
      } catch (e) { /* ë¬´ì‹œ */ }
    }, 10 * 60 * 1000);

    async function postServerScore(name, score) {
      try {
        const res = await fetch(`${API_BASE}/api/scores`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ name, score })
        });
        if (!res.ok) throw new Error('post failed');
        return await res.json();
      } catch (e) {
        console.warn('server score post failed:', e);
        return null;
      }
    }

    async function postCheatLog(name, score, playTimeSeconds) {
      try {
        const res = await fetch(`${API_BASE}/api/cheat-logs`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            player_name: name,
            device_info: navigator.userAgent,
            max_reached_height: maxReachedHeight,
            total_positive_jumps: totalPositiveJumps,
            possible_max_height: STARTING_HEIGHT + totalPositiveJumps + 10,
            score: score,
            play_time_seconds: playTimeSeconds,
            game_mode: isInfiniteMode ? 'infinite' : 'normal',
            jump_logs: JSON.stringify(jumpLogs)
          })
        });
        if (!res.ok) throw new Error('cheat log post failed');
        console.log('[ì¹˜íŠ¸ ë¡œê·¸] ì„œë²„ì— ì €ì¥ë¨');
        return await res.json();
      } catch (e) {
        console.warn('cheat log post failed:', e);
        return null;
      }
    }

    async function fetchServerLeaderboard(limit = 10) {
      try {
        const res = await fetch(`${API_BASE}/api/scores/top?limit=${limit}`, { method: 'GET' });
        if (!res.ok) throw new Error('fetch failed');
        return await res.json();
      } catch (e) {
        console.warn('server leaderboard fetch failed:', e);
        return null;
      }
    }

    function renderServerLeaderboardData(data) {
      // ê²Œì„ì˜¤ë²„ í™”ë©´ì˜ ë¦¬ë”ë³´ë“œì— ë Œë”ë§
      const container = leaderboardList.parentElement || leaderboardList;
      leaderboardList.innerHTML = '';
      
      const items = data?.items || [];
      const medals = ['ğŸ‘‘', 'ğŸ¥ˆ', 'ğŸ¥‰'];
      
      // 1~10ìœ„ í‘œì‹œ
      for (let i = 0; i < 10; i++) {
        const rank = i + 1;
        const item = items[i];
        const li = document.createElement('li');
        li.style.cssText = 'display:flex; justify-content:space-between; padding:4px 0; border-bottom:1px solid rgba(255,255,255,0.1);';
        
        if (rank <= 3) {
          li.style.fontWeight = 'bold';
          if (rank === 1) li.style.color = '#ffd700';
          else if (rank === 2) li.style.color = '#c0c0c0';
          else if (rank === 3) li.style.color = '#cd7f32';
        }
        
        if (item) {
          const medal = rank <= 3 ? medals[rank - 1] + ' ' : '';
          li.innerHTML = `<span>${rank}. ${medal}${item.name}</span><span>${item.score}</span>`;
        } else {
          li.innerHTML = `<span style="color:rgba(255,255,255,0.3)">${rank}. â€”</span><span style="color:rgba(255,255,255,0.3)">â€”</span>`;
        }
        
        leaderboardList.appendChild(li);
      }
      
      // 10ìœ„ì™€ 11ìœ„ ì‚¬ì´ ë¶„ë¦¬ì„ 
      if (items.length > 10) {
        const divider = document.createElement('li');
        divider.style.cssText = 'border-bottom:2px dashed rgba(255,255,255,0.3); margin:8px 0; list-style:none;';
        leaderboardList.appendChild(divider);
        
        // 11ìœ„ ì´í›„ í‘œì‹œ
        for (let i = 10; i < items.length; i++) {
          const rank = i + 1;
          const item = items[i];
          const li = document.createElement('li');
          li.style.cssText = 'display:flex; justify-content:space-between; padding:4px 0; border-bottom:1px solid rgba(255,255,255,0.1); color:rgba(255,255,255,0.7);';
          li.innerHTML = `<span>${rank}. ${item.name}</span><span>${item.score}</span>`;
          leaderboardList.appendChild(li);
        }
      }
      
      return true;
    }

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // Game state variables
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    let gameStartTime = 0;
    let isInvincible = false;
    let velocityY = 0, isGrounded = false, onPlatform = null;
    let chargeTime = 0, isCharging = false, chargeDirection = 1;
    const maxCharge = 1.0, chargeSpeed = 0.8;
    let touchActive = false, touchMode = null, touchStartX = 0, touchLastX = 0, passedDeadzone = false;
    const DRAG_GAIN = 0.01, DEADZONE_PX = 8, MIN_JUMP = 0.2;

    // ì í”„ ê¸°ë¡ ì‹œìŠ¤í…œ (ì¹˜íŠ¸ ê°ì§€ìš©)
    let jumpStartY = 0; // ì í”„ ì‹œì‘ ë†’ì´
    let totalPositiveJumps = 0; // ìœ„ë¡œ ì˜¬ë¼ê°„ ì í”„ ë†’ì´ í•©ê³„
    let maxReachedHeight = 0; // ë„ë‹¬í•œ ìµœê³  ë†’ì´
    let jumpLogs = []; // ë§¤ ì í”„ ìƒì„¸ ê¸°ë¡
    let jumpCount = 0; // ì í”„ íšŸìˆ˜
    let cheatDetected = false; // ì¹˜íŠ¸ ê°ì§€ ì—¬ë¶€
    const STARTING_HEIGHT = -2; // ì‹œì‘ ë°œíŒ ë†’ì´

    let hasSavedThisGame = false;
    let finalScoreValue = 0;
    let lastLandedPlatformId = null;
    
    // ë¬´í•œëª¨ë“œ ê´€ë ¨
    let infiniteModeUnlocked = localStorage.getItem('infiniteModeUnlocked') === 'true';
    let isInfiniteMode = false;
    
    // ë¬´í•œëª¨ë“œ í•´ê¸ˆ ì‹œ ë²„íŠ¼ í‘œì‹œ
    if (infiniteModeUnlocked) {
      infiniteModeBtn.style.display = 'block';
    }
    
    // í•´ê¸ˆ íŒì—… í‘œì‹œ (ì²˜ìŒ í•´ê¸ˆ ì‹œ)
    const unlockPopup = document.getElementById('unlockPopup');
    const closeUnlockBtn = document.getElementById('closeUnlockBtn');
    
    if (localStorage.getItem('showUnlockPopup') === 'true') {
      unlockPopup.style.display = 'flex';
      localStorage.removeItem('showUnlockPopup'); // í•œ ë²ˆë§Œ í‘œì‹œ
    }
    
    closeUnlockBtn.addEventListener('click', () => {
      unlockPopup.style.display = 'none';
    });
    
    // ê°œë°œìš© í•´ê¸ˆ í† ê¸€ ë²„íŠ¼
    document.getElementById('devToggleBtn').addEventListener('click', () => {
      if (localStorage.getItem('infiniteModeUnlocked') === 'true') {
        localStorage.removeItem('infiniteModeUnlocked');
        alert('ë¬´í•œëª¨ë“œ ì ê¸ˆë¨ (ìƒˆë¡œê³ ì¹¨ í•„ìš”)');
      } else {
        localStorage.setItem('infiniteModeUnlocked', 'true');
        localStorage.setItem('showUnlockPopup', 'true');
        alert('ë¬´í•œëª¨ë“œ í•´ê¸ˆë¨ (ìƒˆë¡œê³ ì¹¨ í•„ìš”)');
      }
      location.reload();
    });
    
    // ê²Œì„ í´ë¦¬ì–´ ê´€ë ¨
    let isClearSequence = false;
    let clearSequenceStart = 0;
    let clearTargetPos = null; // ë¹¨ë ¤ë“¤ì–´ê°ˆ ëª©í‘œ ìœ„ì¹˜
    let clearScreenX = 0;      // ë¸”ë™í™€ í™”ë©´ X ì¢Œí‘œ (ê³ ì •)
    let clearScreenY = 0;      // ë¸”ë™í™€ í™”ë©´ Y ì¢Œí‘œ (ê³ ì •)

    // Player (ë‹¨ì¼ ë°•ìŠ¤ + ë©´ë³„ ìƒ‰ìƒìœ¼ë¡œ ì…ì²´ê° + ëˆˆ)
    const playerGroup = new THREE.Group();
    
    const playerMaterials = [
      new THREE.MeshBasicMaterial({ color: 0x3377dd }), // +X ì˜¤ë¥¸ìª½
      new THREE.MeshBasicMaterial({ color: 0x3377dd }), // -X ì™¼ìª½
      new THREE.MeshBasicMaterial({ color: 0x55aaff }), // +Y ìœ—ë©´ (ë°ê²Œ)
      new THREE.MeshBasicMaterial({ color: 0x2255aa }), // -Y ì•„ë«ë©´ (ì–´ë‘¡ê²Œ)
      new THREE.MeshBasicMaterial({ color: 0x4499ee }), // +Z ì•ë©´
      new THREE.MeshBasicMaterial({ color: 0x3377dd }), // -Z ë’·ë©´
    ];
    const playerBody = new THREE.Mesh(
      new THREE.BoxGeometry(1, 1, 1),
      playerMaterials
    );
    playerGroup.add(playerBody);
    
    // ëˆˆ ê·¸ë£¹ (ê¹œë¹¡ì„ìš©)
    const leftEyeGroup = new THREE.Group();
    const rightEyeGroup = new THREE.Group();
    
    // ëˆˆ (ì‚¬ê°í˜• - ë ˆíŠ¸ë¡œ ìŠ¤íƒ€ì¼)
    const eyeGeo = new THREE.PlaneGeometry(0.2, 0.26);
    const eyeMat = new THREE.MeshBasicMaterial({ color: 0x111111 });
    
    const leftEye = new THREE.Mesh(eyeGeo, eyeMat);
    leftEyeGroup.add(leftEye);
    
    const rightEye = new THREE.Mesh(eyeGeo, eyeMat);
    rightEyeGroup.add(rightEye);
    
    leftEyeGroup.position.set(-0.2, 0.1, 0.51);
    rightEyeGroup.position.set(0.2, 0.1, 0.51);
    playerGroup.add(leftEyeGroup);
    playerGroup.add(rightEyeGroup);
    
    // ê¹œë¹¡ì„ ìƒíƒœ
    let nextBlinkTime = 1.5 + Math.random() * 2.25;
    let isBlinking = false;
    let blinkProgress = 0;
    
    // í˜¸í™˜ì„±ì„ ìœ„í•œ ì°¸ì¡°
    const player = playerGroup;
    
    player.visible = false; // íƒ€ì´í‹€ì—ì„œëŠ” ìˆ¨ê¹€
    scene.add(player);
    player.position.y = 0;

    // Keyboard
    const input = { left: false, right: false };
    
    document.addEventListener('keydown', async e => {
      if (gameState === 'ready') {
        if (e.code === 'Space') {
          await startAudio();
          startFromReady();
        }
        return;
      }
      if (gameState === 'playing') {
        if (e.code === 'KeyA' || e.code === 'ArrowLeft') input.left = true;
        if (e.code === 'KeyD' || e.code === 'ArrowRight') input.right = true;
        if (e.code === 'Space' && isGrounded && !isCharging) {
          await startAudio();
          isCharging = true;
          startChargeSound();
        }
        if (e.code === 'Escape') {
          pauseGame();
        }
      } else if (gameState === 'paused') {
        if (e.code === 'Escape') {
          resumeGame();
        }
      }
    });
    
    document.addEventListener('keyup', e => {
      if (gameState === 'playing') {
        if (e.code === 'KeyA' || e.code === 'ArrowLeft') input.left = false;
        if (e.code === 'KeyD' || e.code === 'ArrowRight') input.right = false;
        if (e.code === 'Space' && isCharging) {
          stopChargeSound();
          if (isGrounded) {
            velocityY = Math.max(chargeTime, MIN_JUMP);
            isGrounded = false;
            lastLandedPlatformId = null;
            playJumpSound();
            startJumpRecord();
          }
          chargeTime = 0; isCharging = false; chargeDirection = 1;
          chargeFill.style.width = '0%';
        }
      }
    });

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // ì í”„ ê¸°ë¡ ì‹œìŠ¤í…œ (ì¹˜íŠ¸ ê°ì§€)
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    let currentJumpType = 'normal'; // í˜„ì¬ ì í”„ íƒ€ì…
    
    function startJumpRecord(type = 'normal') {
      jumpStartY = player.position.y;
      currentJumpType = type;
    }
    
    function endJumpRecord() {
      const jumpHeight = player.position.y - jumpStartY;
      jumpCount++;
      
      // ì í”„ ë¡œê·¸ ê¸°ë¡
      jumpLogs.push({
        jump_num: jumpCount,
        start_y: parseFloat(jumpStartY.toFixed(2)),
        end_y: parseFloat(player.position.y.toFixed(2)),
        height: parseFloat(jumpHeight.toFixed(2)),
        type: currentJumpType,
        timestamp: Date.now()
      });
      
      // ìœ„ë¡œ ì˜¬ë¼ê°„ ê²½ìš°ë§Œ ëˆ„ì 
      if (jumpHeight > 0) {
        totalPositiveJumps += jumpHeight;
      }
      
      // ìµœê³  ë†’ì´ ê°±ì‹ 
      if (player.position.y > maxReachedHeight) {
        maxReachedHeight = player.position.y;
      }
      
      // ì¹˜íŠ¸ ì²´í¬: ë„ë‹¬ ê°€ëŠ¥í•œ ìµœëŒ€ ë†’ì´ ê³„ì‚°
      const possibleMaxHeight = STARTING_HEIGHT + totalPositiveJumps + 10; // ì—¬ìœ ê°’ 10
      
      if (maxReachedHeight > possibleMaxHeight) {
        cheatDetected = true;
        console.warn(`[ì¹˜íŠ¸ ì˜ì‹¬] ìµœê³ ë†’ì´: ${maxReachedHeight.toFixed(2)}, ê°€ëŠ¥ë†’ì´: ${possibleMaxHeight.toFixed(2)}, ëˆ„ì ì í”„: ${totalPositiveJumps.toFixed(2)}`);
      }
    }
    
    function getHeightCheck() {
      return {
        maxReached: maxReachedHeight,
        totalJumps: totalPositiveJumps,
        possibleMax: STARTING_HEIGHT + totalPositiveJumps + 10,
        isSuspicious: cheatDetected,
        jumpCount: jumpCount
      };
    }

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // ì¼ì‹œì •ì§€ ê¸°ëŠ¥
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    function pauseGame() {
      if (gameState !== 'playing') return;
      gameState = 'paused';
      pauseScreen.style.display = 'block';
      stopChargeSound();
    }

    function resumeGame() {
      if (gameState !== 'paused') return;
      gameState = 'playing';
      pauseScreen.style.display = 'none';
    }

    pauseBtn.addEventListener('click', () => {
      if (gameState === 'playing') pauseGame();
      else if (gameState === 'paused') resumeGame();
    });

    resumeBtn.addEventListener('click', resumeGame);
    restartBtn.addEventListener('click', () => {
      pauseScreen.style.display = 'none';
      resetGameForReplay();
    });
    quitBtn.addEventListener('click', () => window.location.reload());

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // íƒ€ì´í‹€ & ì¡°ì‘ë²• í™”ë©´
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    controlsBtn.addEventListener('click', async () => {
      await startTitleDrone();
      playButtonSound();
      controlsScreen.style.display = 'block';
    });

    closeControlsBtn.addEventListener('click', () => {
      playButtonSound();
      controlsScreen.style.display = 'none';
    });

    // ë¦¬ë”ë³´ë“œ í™”ë©´ (íƒ€ì´í‹€ì—ì„œ)
    leaderboardTitleBtn.addEventListener('click', async () => {
      await startTitleDrone();
      playButtonSound();
      leaderboardScreen.style.display = 'block';
      leaderboardScreenContent.innerHTML = '<p style="color:rgba(255,255,255,0.5);">ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘...</p>';
      
      const data = await fetchServerLeaderboard(10);
      renderLeaderboardToElement(data, leaderboardScreenContent);
    });

    closeLeaderboardBtn.addEventListener('click', () => {
      playButtonSound();
      leaderboardScreen.style.display = 'none';
    });

    // ë¦¬ë”ë³´ë“œ ë Œë”ë§ (íƒ€ê²Ÿ elementì—)
    function renderLeaderboardToElement(data, targetEl) {
      targetEl.innerHTML = '';
      const items = data?.items || [];
      const medals = ['ğŸ‘‘', 'ğŸ¥ˆ', 'ğŸ¥‰'];
      
      const ul = document.createElement('ul');
      ul.style.cssText = 'padding-left:0;margin:0;list-style:none;';
      
      // 1~10ìœ„ í‘œì‹œ
      for (let i = 0; i < 10; i++) {
        const rank = i + 1;
        const item = items[i];
        const li = document.createElement('li');
        li.style.cssText = 'display:flex; justify-content:space-between; padding:6px 0; border-bottom:1px solid rgba(255,255,255,0.1);';
        
        if (rank <= 3) {
          li.style.fontWeight = 'bold';
          if (rank === 1) li.style.color = '#ffd700';
          else if (rank === 2) li.style.color = '#c0c0c0';
          else if (rank === 3) li.style.color = '#cd7f32';
        }
        
        if (item) {
          const medal = rank <= 3 ? medals[rank - 1] + ' ' : '';
          li.innerHTML = `<span>${rank}. ${medal}${item.name}</span><span>${item.score}</span>`;
        } else {
          li.innerHTML = `<span style="color:rgba(255,255,255,0.3)">${rank}. â€”</span><span style="color:rgba(255,255,255,0.3)">â€”</span>`;
        }
        
        ul.appendChild(li);
      }
      
      // 10ìœ„ì™€ 11ìœ„ ì‚¬ì´ ë¶„ë¦¬ì„ 
      if (items.length > 10) {
        const divider = document.createElement('li');
        divider.style.cssText = 'border-bottom:2px dashed rgba(255,255,255,0.3); margin:10px 0; list-style:none;';
        ul.appendChild(divider);
        
        // 11ìœ„ ì´í›„ í‘œì‹œ
        for (let i = 10; i < items.length; i++) {
          const rank = i + 1;
          const item = items[i];
          const li = document.createElement('li');
          li.style.cssText = 'display:flex; justify-content:space-between; padding:6px 0; border-bottom:1px solid rgba(255,255,255,0.1); color:rgba(255,255,255,0.7);';
          li.innerHTML = `<span>${rank}. ${item.name}</span><span>${item.score}</span>`;
          ul.appendChild(li);
        }
      }
      
      targetEl.appendChild(ul);
      
      if (items.length === 0) {
        targetEl.innerHTML = '<p style="color:rgba(255,255,255,0.5); text-align:center;">ì•„ì§ ê¸°ë¡ì´ ì—†ìŠµë‹ˆë‹¤</p>';
      }
    }

    startBtn.addEventListener('click', async () => {
      await startAudio();
      playButtonSound();
      isInfiniteMode = false;
      startBlackholeDrone();
      startCountdown();
    });

    infiniteModeBtn.addEventListener('click', async () => {
      await startAudio();
      playButtonSound();
      isInfiniteMode = true;
      startBlackholeDrone();
      startCountdown();
    });

    function startCountdown() {
      gameState = 'countdown';
      titleScreen.style.display = 'none';
      
      // ë¸”ë™í™€ ë“œë¡  í˜ì´ë“œì•„ì›ƒ (2ì´ˆì— ê±¸ì³)
      stopBlackholeDrone();
      
      let count = 3;
      countdownEl.style.display = 'block';
      countdownEl.textContent = count;
      playCountdownSound();

      // ë¸”ë™í™€ ìˆ˜ì¶• íš¨ê³¼ ì‹œì‘ (ì´ìŠ¤í„°ì—ê·¸ ìŠ¤íƒ€ì¼)
      const blackholeSuctionStart = performance.now();
      const growDuration = 2500;   // ì»¤ì§€ë©´ì„œ ë–¨ë¦¼ 2.5ì´ˆ
      const collapseDuration = 500; // ìˆ˜ì¶• 0.5ì´ˆ
      const totalDuration = growDuration + collapseDuration;
      let collapseSoundPlayed = false;

      function animateSuction() {
        const now = performance.now();
        const elapsed = now - blackholeSuctionStart;
        
        if (elapsed < growDuration) {
          // ë¸”ë™í™€ ì»¤ì§€ë©´ì„œ ì¹´ë©”ë¼ ë–¨ë¦¼ (2.5ì´ˆ)
          const progress = elapsed / growDuration;
          const easeProgress = Math.pow(progress, 3);
          
          // ë¸”ë™í™€ ì ì  ì»¤ì§
          const scale = 1 + easeProgress * 0.3;
          titleBlackholeGroup.scale.setScalar(scale);
          
          // ì¹´ë©”ë¼ í”ë“¤ë¦¼ (ì ì  ê°•í•´ì§)
          const camShake = progress * 0.5;
          camera.position.x = (Math.random() - 0.5) * camShake;
          camera.position.y = 5 + (Math.random() - 0.5) * camShake;
          
          // íŒŒí‹°í´ ë¹¨ë ¤ë“¤ì–´ê°
          const particles = titleBlackholeGroup.children.find(c => c.type === 'Points' && c.geometry.attributes.position.count === titleParticleCount);
          if (particles) {
            const positions = particles.geometry.attributes.position.array;
            for (let i = 0; i < titleParticleCount; i++) {
              titleParticleAngles[i] += 0.02 + easeProgress * 0.03;
              titleParticleRadii[i] -= 0.02 + easeProgress * 0.05;
              if (titleParticleRadii[i] < 5.5) {
                titleParticleRadii[i] = 6 + Math.random() * 18;
              }
              positions[i * 3] = Math.cos(titleParticleAngles[i]) * titleParticleRadii[i];
              positions[i * 3 + 1] = 0;
              positions[i * 3 + 2] = Math.sin(titleParticleAngles[i]) * titleParticleRadii[i];
            }
            particles.geometry.attributes.position.needsUpdate = true;
          }
          
          requestAnimationFrame(animateSuction);
        } else if (elapsed < totalDuration) {
          // ìˆ˜ì¶• (0.5ì´ˆ)
          const collapseProgress = (elapsed - growDuration) / collapseDuration;
          
          // ìˆ˜ì¶• ì‹œì‘í•  ë•Œ ì†Œë¦¬ (í•œë²ˆë§Œ)
          if (!collapseSoundPlayed) {
            collapseSoundPlayed = true;
            playClearCollapseSound();
          }
          
          // ì¹´ë©”ë¼ ê³„ì† í”ë“¤ë¦¼
          const camShake = 0.5;
          camera.position.x = (Math.random() - 0.5) * camShake;
          camera.position.y = 5 + (Math.random() - 0.5) * camShake;
          
          // ë¸”ë™í™€ ê¸‰ê²©íˆ ìˆ˜ì¶• (1.3ì—ì„œ ì‹œì‘)
          const collapseScale = Math.max(0.001, 1.3 * Math.pow(1 - collapseProgress, 4));
          titleBlackholeGroup.scale.setScalar(collapseScale);
          
          // íŒŒí‹°í´ ê¸‰ê²©íˆ ì¤‘ì‹¬ìœ¼ë¡œ
          const particles = titleBlackholeGroup.children.find(c => c.type === 'Points' && c.geometry.attributes.position.count === titleParticleCount);
          if (particles) {
            const positions = particles.geometry.attributes.position.array;
            for (let i = 0; i < titleParticleCount; i++) {
              titleParticleRadii[i] *= 0.85;
              positions[i * 3] = Math.cos(titleParticleAngles[i]) * titleParticleRadii[i];
              positions[i * 3 + 1] = 0;
              positions[i * 3 + 2] = Math.sin(titleParticleAngles[i]) * titleParticleRadii[i];
            }
            particles.geometry.attributes.position.needsUpdate = true;
          }
          
          // ë°°ê²½ìƒ‰ ì „í™˜ (ìš°ì£¼ â†’ í•˜ëŠ˜) + ë²ˆì©
          let r = Math.floor(10 + (208 - 10) * collapseProgress);
          let g = Math.floor(5 + (240 - 5) * collapseProgress);
          let b = Math.floor(21 + (255 - 21) * collapseProgress);
          
          // ë²ˆì©! (ë§ˆì§€ë§‰ì— ë°ì•„ì§)
          if (collapseProgress > 0.85) {
            const flashIntensity = (collapseProgress - 0.85) / 0.15;
            const c = Math.floor(flashIntensity * 255);
            r = Math.min(255, r + c);
            g = Math.min(255, g + c);
            b = Math.min(255, b + c);
          }
          
          scene.background = new THREE.Color(`rgb(${r},${g},${b})`);
          
          // ë³„ í˜ì´ë“œì•„ì›ƒ
          starsMaterial.opacity = Math.max(0, 1 - collapseProgress * 2);
          
          requestAnimationFrame(animateSuction);
        } else {
          // ì™„ë£Œ
          titleBlackholeGroup.visible = false;
          scene.background = new THREE.Color(0xd0f0ff);
          camera.position.set(0, 5, 10);
        }
        
        // ë Œë”ë§
        renderer.render(scene, camera);
      }
      
      animateSuction();

      const countInterval = setInterval(() => {
        count--;
        if (count > 0) {
          countdownEl.textContent = count;
          countdownEl.style.animation = 'none';
          countdownEl.offsetHeight; // reflow
          countdownEl.style.animation = 'countPulse 1s ease-out';
          playCountdownSound();
        } else {
          clearInterval(countInterval);
          countdownEl.textContent = 'GO!';
          countdownEl.style.animation = 'none';
          countdownEl.offsetHeight;
          countdownEl.style.animation = 'countPulse 1s ease-out';
          playStartSound();

          setTimeout(() => {
            countdownEl.style.display = 'none';
            startGame();
          }, 500);
        }
      }, 1000);
    }

    function transitionToSky(progress) {
      // ì´ì œ animateSuctionì—ì„œ ì²˜ë¦¬í•˜ë¯€ë¡œ ë¹ˆ í•¨ìˆ˜
    }

    function startGame() {
      gameState = 'playing';
      gameStartTime = Date.now();
      isInvincible = false;

      // UI í‘œì‹œ
      scoreEl.style.display = 'block';
      chargeBar.style.display = 'block';
      pauseBtn.style.display = 'block';

      // íƒ€ì´í‹€ ë¸”ë™í™€ ìˆ¨ê¹€
      titleBlackholeGroup.visible = false;

      // êµ¬ë¦„ í‘œì‹œ
      cloudsGroup.visible = true;
      
      // íƒœì–‘ í‘œì‹œ
      sunGroup.visible = true;

      // í”Œë ˆì´ì–´ í‘œì‹œ
      player.visible = true;
      player.position.set(0, 0, 0);

      // ë°œíŒ ìƒì„±
      createPlatform(0, -2, 'start');
      for (let i = 0; i < 10; i++) {
        const type = getRandomPlatformType();
        createPlatform((Math.random() - 0.5) * 5, i * 3, type);
      }

      // Death plate ìƒì„±
      createDeathPlate();
    }

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // ì €ì¥ ë²„íŠ¼ ê´€ë ¨
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    function enableSaveButtonIfReady() {
      const hasName = !!(playerNameInput?.value.trim());
      if (submitScoreBtn) {
        submitScoreBtn.disabled = !hasName || hasSavedThisGame;
        submitScoreBtn.style.opacity = submitScoreBtn.disabled ? '0.6' : '1';
      }
    }

    async function saveToServer(name, score) {
      if (hasSavedThisGame) return true;

      const result = await postServerScore(name, score);
      if (!result) {
        alert('ì„œë²„ ì €ì¥ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.');
        return false;
      }

      // ì¹˜íŠ¸ ê°ì§€ëœ ê²½ìš° ì¹˜íŠ¸ ë¡œê·¸ë„ ì €ì¥
      if (cheatDetected) {
        const playTimeSeconds = Math.floor((Date.now() - gameStartTime) / 1000);
        await postCheatLog(name, score, playTimeSeconds);
      }

      hasSavedThisGame = true;
      if (submitScoreBtn) {
        submitScoreBtn.disabled = true;
        submitScoreBtn.textContent = 'Saved!';
      }

      playSaveSound();

      const serverList = await fetchServerLeaderboard(10);
      renderServerLeaderboardData(serverList);

      return true;
    }

    playerNameInput?.addEventListener('input', enableSaveButtonIfReady);

    submitScoreBtn?.addEventListener('click', async () => {
      if (hasSavedThisGame) return;
      let name = (playerNameInput?.value || '').trim();
      if (!name) {
        nameHint && (nameHint.style.display = 'block');
        const ok = confirm("ì´ë¦„ì´ ë¹„ì–´ ìˆìŠµë‹ˆë‹¤. 'noname'ìœ¼ë¡œ ì €ì¥í• ê¹Œìš”?");
        if (!ok) { playerNameInput?.focus(); return; }
        name = 'noname';
        if (playerNameInput) playerNameInput.value = name;
      }

      await saveToServer(name, finalScoreValue);
    });

    playAgainBtn?.addEventListener('click', async () => {
      if (!hasSavedThisGame) {
        const wantSave = confirm("í˜„ì¬ ì ìˆ˜ë¥¼ ì €ì¥í•˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤. ì €ì¥í•˜ê³  ìƒˆë¡œ ì‹œì‘í• ê¹Œìš”?");
        if (wantSave) {
          let name = (playerNameInput?.value || '').trim();
          if (!name) {
            const ok = confirm("ì´ë¦„ì´ ë¹„ì–´ ìˆìŠµë‹ˆë‹¤. 'noname'ìœ¼ë¡œ ì €ì¥í• ê¹Œìš”?");
            if (!ok) { playerNameInput?.focus(); return; }
            name = 'noname';
            if (playerNameInput) playerNameInput.value = name;
          }
          const saved = await saveToServer(name, finalScoreValue);
          if (!saved) return;
        }
      }
      // ê²Œì„ ë¦¬ì…‹í•˜ê³  ready ìƒíƒœë¡œ
      resetGameForReplay();
    });

    function resetGameForReplay() {
      // ê²Œì„ì˜¤ë²„ í™”ë©´ ìˆ¨ê¸°ê¸°
      gameOverScreen.style.display = 'none';
      
      // ê²Œì„ ìƒíƒœ ì´ˆê¸°í™”
      gameState = 'ready';
      hasSavedThisGame = false;
      finalScoreValue = 0;
      maxY = 0;
      nextPlatformY = 30;
      velocityY = 0;
      isGrounded = false;
      onPlatform = null;
      chargeTime = 0;
      isCharging = false;
      chargeDirection = 1;
      lastLandedPlatformId = null;
      isInvincible = false;
      
      // ì…ë ¥ ìƒíƒœ ë¦¬ì…‹
      input.left = false;
      input.right = false;
      
      // ì í”„ ê¸°ë¡ ë¦¬ì…‹
      jumpStartY = 0;
      totalPositiveJumps = 0;
      maxReachedHeight = 0;
      jumpLogs = [];
      jumpCount = 0;
      cheatDetected = false;
      
      // í´ë¦¬ì–´ ê´€ë ¨ ë¦¬ì…‹
      isClearSequence = false;
      clearTargetPos = null;
      clearScreenX = 0;
      clearScreenY = 0;
      clearSoundPlayed = { pulse: false, collapse: false };
      
      // ê¸°ì¡´ ë°œíŒ ì œê±°
      platforms.forEach(p => {
        p.userData.label?.remove?.();
        scene.remove(p);
      });
      platforms.length = 0;
      platformIdCounter = 0;
      
      // ê¸°ì¡´ Death Plate ì œê±°
      if (deathPlate) {
        scene.remove(deathPlate);
        deathPlate = null;
      }
      
      // ì¹´ë©”ë¼ ë¦¬ì…‹
      camera.position.set(0, 5, 10);
      
      // ë°°ê²½ ë¦¬ì…‹ (í•˜ëŠ˜ìƒ‰)
      scene.background = new THREE.Color(0xd0f0ff);
      starsMaterial.opacity = 0;
      cloudsGroup.visible = true;
      sunGroup.visible = true;
      clouds.forEach(cloud => {
        cloud.children.forEach(puff => {
          // ê° puffì˜ ê¸°ë³¸ íˆ¬ëª…ë„ ë³µì›
          const baseOpacity = 0.5 + Math.random() * 0.3;
          puff.material.opacity = baseOpacity;
          puff.userData = { lastCloudOpacity: 1 };
        });
      });
      
      // í”Œë ˆì´ì–´ ë¦¬ì…‹
      player.position.set(0, 0, 0);
      player.visible = true;
      
      // ë°œíŒ ìƒì„±
      createPlatform(0, -2, 'start');
      for (let i = 0; i < 10; i++) {
        const type = getRandomPlatformType();
        createPlatform((Math.random() - 0.5) * 5, i * 3, type);
      }
      
      // Death plate ìƒì„±
      createDeathPlate();
      
      // UI í‘œì‹œ
      scoreEl.style.display = 'block';
      scoreEl.innerText = 'Score: 0';
      chargeBar.style.display = 'block';
      chargeFill.style.width = '0%';
      pauseBtn.style.display = 'none';
      
      // Ready í™”ë©´ í‘œì‹œ
      readyScreen.style.display = 'flex';
    }

    function startFromReady() {
      if (gameState !== 'ready') return;
      
      readyScreen.style.display = 'none';
      gameState = 'playing';
      gameStartTime = Date.now();
      pauseBtn.style.display = 'block';
      playStartSound();
    }

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // Touch controls
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    const passiveFalse = { passive: false };
    
    async function onTouchStart(e) {
      if (gameState === 'ready') {
        e.preventDefault();
        await startAudio();
        startFromReady();
        return;
      }
      if (gameState !== 'playing') return;
      e.preventDefault();
      await startAudio();
      const t = e.touches[0]; touchActive = true; touchStartX = t.clientX; touchLastX = t.clientX; passedDeadzone = false;
      if (isGrounded && !isCharging) { 
        touchMode = 'charge'; 
        isCharging = true; 
        startChargeSound();
      } else { 
        touchMode = 'drag'; 
      }
    }
    
    function onTouchMove(e) {
      if (gameState !== 'playing') return;
      e.preventDefault(); if (!touchActive) return;
      const t = e.touches[0]; if (touchMode === 'drag') {
        if (!passedDeadzone && Math.abs(t.clientX - touchStartX) >= DEADZONE_PX) passedDeadzone = true;
        if (passedDeadzone && !isGrounded) { 
          const dx = t.clientX - touchLastX; 
          player.position.x += dx * DRAG_GAIN;
          // X ë²”ìœ„ ì œí•œ
          player.position.x = Math.max(-7.5, Math.min(7.5, player.position.x));
        }
        touchLastX = t.clientX;
      }
    }
    
    function onTouchEnd(e) {
      if (gameState !== 'playing') return;
      e.preventDefault();
      if (touchMode === 'charge' && isCharging) {
        stopChargeSound();
        if (isGrounded) {
          velocityY = Math.max(chargeTime, MIN_JUMP);
          isGrounded = false;
          lastLandedPlatformId = null;
          playJumpSound();
          startJumpRecord();
        }
        chargeTime = 0; isCharging = false; chargeDirection = 1;
        chargeFill.style.width = '0%';
      }
      touchActive = false; touchMode = null;
    }
    
    renderer.domElement.addEventListener('touchstart', onTouchStart, passiveFalse);
    renderer.domElement.addEventListener('touchmove', onTouchMove, passiveFalse);
    renderer.domElement.addEventListener('touchend', onTouchEnd, passiveFalse);
    renderer.domElement.addEventListener('touchcancel', onTouchEnd, passiveFalse);

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // Platforms
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    const platforms = [];
    let platformIdCounter = 0;
    
    // ìƒ‰ìƒ ë°ê¸° ì¡°ì ˆ í—¬í¼
    function adjustColor(hex, factor) {
      const r = Math.min(255, Math.floor(((hex >> 16) & 0xff) * factor));
      const g = Math.min(255, Math.floor(((hex >> 8) & 0xff) * factor));
      const b = Math.min(255, Math.floor((hex & 0xff) * factor));
      return (r << 16) | (g << 8) | b;
    }

    function createPlatform(x, y, type = 'normal') {
      let width, color, special = null;
      switch (type) {
        case 'start': width = 15; color = 0x999999; break;
        case 'narrow': width = 1.2; color = 0xff6666; break;
        case 'bounce': width = 3; color = 0x6666ff; special = 'bounce'; break;
        case 'vanish': width = 3; color = 0xffff44; special = 'vanish'; break;
        case 'crumble': width = 3; color = 0xbb9977; special = 'crumble'; break;
        case 'superBounce': width = 2; color = 0xff66ff; special = 'superBounce'; break;
        case 'deadly': width = 2.5; color = 0x222222; special = 'deadly'; break;
        default: width = 3; color = 0x44dd44;
      }
      
      // ë©´ë³„ ìƒ‰ìƒ ê³„ì‚°
      const topColor = adjustColor(color, 1.15);    // ìœ—ë©´ ë°ê²Œ
      const sideColor = color;                       // ì˜†ë©´ ê¸°ë³¸
      const bottomColor = adjustColor(color, 0.6);  // ì•„ë«ë©´ ì–´ë‘¡ê²Œ
      const frontColor = adjustColor(color, 0.85);  // ì•ë©´ ì•½ê°„ ì–´ë‘¡ê²Œ
      
      // ë©”ì¸ ê·¸ë£¹
      const platformGroup = new THREE.Group();
      platformGroup.position.set(x, y, 0);
      
      // ë©´ë³„ ìƒ‰ìƒ Materials (ì¨í•œ BasicMaterial!)
      const platformMaterials = [
        new THREE.MeshBasicMaterial({ color: sideColor, transparent: true }),   // +X
        new THREE.MeshBasicMaterial({ color: sideColor, transparent: true }),   // -X
        new THREE.MeshBasicMaterial({ color: topColor, transparent: true }),    // +Y (ìœ—ë©´)
        new THREE.MeshBasicMaterial({ color: bottomColor, transparent: true }), // -Y (ì•„ë«ë©´)
        new THREE.MeshBasicMaterial({ color: frontColor, transparent: true }),  // +Z (ì•ë©´)
        new THREE.MeshBasicMaterial({ color: sideColor, transparent: true }),   // -Z
      ];
      
      const platformMesh = new THREE.Mesh(
        new THREE.BoxGeometry(width, 0.5, 1),
        platformMaterials
      );
      platformGroup.add(platformMesh);
      
      // íŒì •ìš© (ê¸°ì¡´ ë¡œì§ í˜¸í™˜)
      const mesh = platformGroup;
      mesh.geometry = { parameters: { width } };
      mesh.material = platformMaterials[2]; // ìœ—ë©´ ìƒ‰ìƒ ì°¸ì¡°

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // Crumble ë°œíŒ: í‰ì†Œ ë¨¼ì§€ + ì°©ì§€ ì‹œ ê· ì—´
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      if (type === 'crumble') {
        // ë¨¼ì§€ íŒŒí‹°í´ ì‹œìŠ¤í…œ (ë¶ˆê·œì¹™í•˜ê²Œ ë–¨ì–´ì§€ëŠ” ë¨¼ì§€) - ëŒ€í­ ê°•í™”
        const dustCount = 60; // ë” ë§ì´!
        const dustGeom = new THREE.BufferGeometry();
        const dustPositions = new Float32Array(dustCount * 3);
        const dustData = []; // ê° ë¨¼ì§€ì˜ ìƒíƒœ
        const dustWidth = width * 1.3; // ë°œíŒë³´ë‹¤ 30% ë„“ê²Œ
        
        for (let i = 0; i < dustCount; i++) {
          // ê°€ì¥ìë¦¬ì—ì„œ ì£¼ë¡œ ìƒì„±
          const edgeBias = Math.random() < 0.6; // 60%ëŠ” ê°€ì¥ìë¦¬
          let px;
          if (edgeBias) {
            // ê°€ì¥ìë¦¬ (ë°œíŒ ë°”ê¹¥ê¹Œì§€ í¬í•¨)
            const side = Math.random() < 0.5 ? -1 : 1;
            px = side * (dustWidth / 2 - Math.random() * 0.5);
          } else {
            // ëœë¤
            px = (Math.random() - 0.5) * dustWidth;
          }
          
          const startY = 0.3 + Math.random() * 0.3;
          dustPositions[i * 3] = px;
          dustPositions[i * 3 + 1] = startY;
          dustPositions[i * 3 + 2] = (Math.random() - 0.5) * 1.2;
          
          dustData.push({
            baseX: px,
            baseZ: dustPositions[i * 3 + 2],
            fallSpeed: 0.8 + Math.random() * 1.2, // ë” ë¹ ë¥´ê²Œ
            wobble: Math.random() * Math.PI * 2,
            wobbleSpeed: 3 + Math.random() * 4,
            wobbleAmount: 0.03 + Math.random() * 0.05, // í”ë“¤ë¦¼ í¬ê¸°
            delay: Math.random() * 0.8, // ì§§ì€ ë”œë ˆì´
            active: false,
            y: startY,
            resetY: -1.5 - Math.random() * 1.5, // ë” ì•„ë˜ê¹Œì§€ + ëœë¤ ìœ„ì¹˜ì—ì„œ ì‚¬ë¼ì§
            size: 0.8 + Math.random() * 0.4, // ê°œë³„ í¬ê¸° ë³€í™”
            dustWidth: dustWidth // ë¦¬ì…‹ìš© ì €ì¥
          });
        }
        
        dustGeom.setAttribute('position', new THREE.BufferAttribute(dustPositions, 3));
        const dustMat = new THREE.PointsMaterial({
          color: 0xaa9988,
          size: 0.12, // ë” í¬ê²Œ!
          transparent: true,
          opacity: 0.7
        });
        const dust = new THREE.Points(dustGeom, dustMat);
        platformGroup.add(dust);
        
        // ê· ì—´ ë¼ì¸ë“¤ (ì´ˆê¸°ì—ëŠ” ìˆ¨ê¹€, ì°©ì§€ ì‹œ í‘œì‹œ)
        const crackGroup = new THREE.Group();
        crackGroup.visible = false;
        
        // ê· ì—´ ë°ì´í„° (ì¤‘ì•™ì—ì„œ ë»—ì–´ë‚˜ê°€ëŠ” 4ê°ˆë˜, ë°œíŒ ëê¹Œì§€)
        const crackLines = [];
        const crackCount = 4;
        const halfWidth = width / 2;
        const halfDepth = 0.5;
        
        for (let i = 0; i < crackCount; i++) {
          const angle = (i / crackCount) * Math.PI * 2 + Math.PI / 8 + (Math.random() - 0.5) * 0.5;
          
          // ê°ë„ì— ë”°ë¼ ë°œíŒ ê²½ê³„ê¹Œì§€ì˜ ìµœëŒ€ ê¸¸ì´ ê³„ì‚°
          const cosA = Math.cos(angle);
          const sinA = Math.sin(angle);
          let maxLength = 10; // í° ê°’ìœ¼ë¡œ ì‹œì‘
          
          // X ê²½ê³„ ì²´í¬
          if (Math.abs(cosA) > 0.01) {
            const xLimit = halfWidth / Math.abs(cosA);
            maxLength = Math.min(maxLength, xLimit);
          }
          // Z ê²½ê³„ ì²´í¬
          if (Math.abs(sinA) > 0.01) {
            const zLimit = halfDepth / Math.abs(sinA * 0.3); // ZëŠ” 0.3 ìŠ¤ì¼€ì¼
            maxLength = Math.min(maxLength, zLimit);
          }
          
          const length = maxLength * (0.85 + Math.random() * 0.15); // ê²½ê³„ì˜ 85~100%
          
          // ë©”ì¸ ê· ì—´
          const points = [
            new THREE.Vector3(0, 0.26, 0),
            new THREE.Vector3(
              cosA * length * 0.4,
              0.26,
              sinA * length * 0.2
            ),
            new THREE.Vector3(
              cosA * length,
              0.26,
              sinA * length * 0.3
            )
          ];
          
          const crackGeom = new THREE.BufferGeometry().setFromPoints(points);
          const crackMat = new THREE.LineBasicMaterial({
            color: 0x332211,
            transparent: true,
            opacity: 0,
            linewidth: 2
          });
          const crackLine = new THREE.Line(crackGeom, crackMat);
          crackLines.push({
            line: crackLine,
            targetOpacity: 0.9,
            length: length,
            points: points
          });
          crackGroup.add(crackLine);
          
          // ë¶„ê¸° ê· ì—´ (50% í™•ë¥ )
          if (Math.random() < 0.5) {
            const branchAngle = angle + (Math.random() - 0.5) * 1.2;
            const branchLength = length * 0.3;
            const branchStart = points[1].clone();
            
            // ë¶„ê¸°ë„ ê²½ê³„ ì²´í¬
            let branchEndX = branchStart.x + Math.cos(branchAngle) * branchLength;
            let branchEndZ = branchStart.z + Math.sin(branchAngle) * branchLength * 0.3;
            branchEndX = Math.max(-halfWidth, Math.min(halfWidth, branchEndX));
            branchEndZ = Math.max(-halfDepth, Math.min(halfDepth, branchEndZ));
            
            const branchPoints = [
              branchStart,
              new THREE.Vector3(branchEndX, 0.26, branchEndZ)
            ];
            
            const branchGeom = new THREE.BufferGeometry().setFromPoints(branchPoints);
            const branchMat = new THREE.LineBasicMaterial({
              color: 0x443322,
              transparent: true,
              opacity: 0
            });
            const branchLine = new THREE.Line(branchGeom, branchMat);
            crackLines.push({
              line: branchLine,
              targetOpacity: 0.7,
              length: branchLength,
              points: branchPoints,
              isBranch: true
            });
            crackGroup.add(branchLine);
          }
        }
        
        platformGroup.add(crackGroup);
        
        // ì¶©ê²© ì´í™íŠ¸ (ì°©ì§€ ì‹œ ì¤‘ì•™ì—ì„œ í¼ì§€ëŠ” ë§)
        const impactRing = new THREE.Mesh(
          new THREE.RingGeometry(0, 0.1, 16),
          new THREE.MeshBasicMaterial({
            color: 0xffaa44,
            transparent: true,
            opacity: 0,
            side: THREE.DoubleSide
          })
        );
        impactRing.rotation.x = -Math.PI / 2;
        impactRing.position.y = 0.27;
        platformGroup.add(impactRing);
        
        // userDataì— ì €ì¥
        platformGroup.userData.dust = dust;
        platformGroup.userData.dustData = dustData;
        platformGroup.userData.crackGroup = crackGroup;
        platformGroup.userData.crackLines = crackLines;
        platformGroup.userData.impactRing = impactRing;
        platformGroup.userData.crackStartTime = null;
        platformGroup.userData.crackProgress = 0;
        platformGroup.userData.dustBurst = false;
        platformGroup.userData.dustBurstTime = null;
      }

      // Bounce ë°œíŒ: ê¸€ë¡œìš° + í™”ì‚´í‘œ ì•„ì´ì½˜
      if (type === 'bounce') {
        const bounceGlow = new THREE.Mesh(
          new THREE.RingGeometry(1.0, 1.5, 32),
          new THREE.MeshBasicMaterial({
            color: 0x6666ff,
            transparent: true,
            opacity: 0.3,
            side: THREE.DoubleSide
          })
        );
        bounceGlow.rotation.x = -Math.PI / 2;
        bounceGlow.position.y = 0.28;
        platformGroup.add(bounceGlow);
        platformGroup.userData.bounceGlow = bounceGlow;
        
        // ìœ„ í™”ì‚´í‘œ ì•„ì´ì½˜ â†‘ (ë°œíŒ ì•ì— ì„¸ì›Œì„œ í‘œì‹œ)
        const arrowShape = new THREE.Shape();
        arrowShape.moveTo(0, 0.35);
        arrowShape.lineTo(-0.18, 0.05);
        arrowShape.lineTo(-0.07, 0.05);
        arrowShape.lineTo(-0.07, -0.2);
        arrowShape.lineTo(0.07, -0.2);
        arrowShape.lineTo(0.07, 0.05);
        arrowShape.lineTo(0.18, 0.05);
        arrowShape.lineTo(0, 0.35);
        const arrowGeom = new THREE.ShapeGeometry(arrowShape);
        const arrowMat = new THREE.MeshBasicMaterial({ color: 0xffffff, side: THREE.DoubleSide });
        const arrowIcon = new THREE.Mesh(arrowGeom, arrowMat);
        arrowIcon.position.set(0, 0.25, 0.55);
        arrowIcon.scale.setScalar(0.7);
        platformGroup.add(arrowIcon);
      }

      // SuperBounce ë°œíŒ: ê¸€ë¡œìš° + ì´ì¤‘ í™”ì‚´í‘œ ì•„ì´ì½˜
      if (type === 'superBounce') {
        const innerGlow = new THREE.Mesh(
          new THREE.RingGeometry(0.8, 1.2, 32),
          new THREE.MeshBasicMaterial({
            color: 0xff00ff,
            transparent: true,
            opacity: 0.6,
            side: THREE.DoubleSide
          })
        );
        innerGlow.rotation.x = -Math.PI / 2;
        innerGlow.position.y = 0.3;
        platformGroup.add(innerGlow);
        platformGroup.userData.innerGlow = innerGlow;

        const outerGlow = new THREE.Mesh(
          new THREE.RingGeometry(1.3, 1.8, 32),
          new THREE.MeshBasicMaterial({
            color: 0xff66ff,
            transparent: true,
            opacity: 0.3,
            side: THREE.DoubleSide
          })
        );
        outerGlow.rotation.x = -Math.PI / 2;
        outerGlow.position.y = 0.35;
        platformGroup.add(outerGlow);
        platformGroup.userData.outerGlow = outerGlow;

        const sparkleGeom = new THREE.BufferGeometry();
        const sparkleCount = 8;
        const sparklePositions = new Float32Array(sparkleCount * 3);
        for (let i = 0; i < sparkleCount; i++) {
          const angle = (i / sparkleCount) * Math.PI * 2;
          sparklePositions[i * 3] = Math.cos(angle) * 0.9;
          sparklePositions[i * 3 + 1] = 0.4;
          sparklePositions[i * 3 + 2] = Math.sin(angle) * 0.9;
        }
        sparkleGeom.setAttribute('position', new THREE.BufferAttribute(sparklePositions, 3));
        const sparkleMat = new THREE.PointsMaterial({
          color: 0xffffff,
          size: 0.15,
          transparent: true,
          opacity: 0.8
        });
        const sparkles = new THREE.Points(sparkleGeom, sparkleMat);
        platformGroup.add(sparkles);
        platformGroup.userData.sparkles = sparkles;
        
        // ì´ì¤‘ í™”ì‚´í‘œ ì•„ì´ì½˜ â¬†â¬† (ë°œíŒ ì•ì— ì„¸ì›Œì„œ í‘œì‹œ)
        const dblArrowGroup = new THREE.Group();
        
        // ì²«ë²ˆì§¸ í™”ì‚´í‘œ (ìœ„)
        const arrow1Shape = new THREE.Shape();
        arrow1Shape.moveTo(0, 0.22);
        arrow1Shape.lineTo(-0.15, 0);
        arrow1Shape.lineTo(0.15, 0);
        arrow1Shape.lineTo(0, 0.22);
        const arrow1Geom = new THREE.ShapeGeometry(arrow1Shape);
        const arrow1Mat = new THREE.MeshBasicMaterial({ color: 0xffffff, side: THREE.DoubleSide });
        const arrow1 = new THREE.Mesh(arrow1Geom, arrow1Mat);
        arrow1.position.y = 0.15;
        dblArrowGroup.add(arrow1);
        
        // ë‘ë²ˆì§¸ í™”ì‚´í‘œ (ì•„ë˜)
        const arrow2 = new THREE.Mesh(arrow1Geom.clone(), arrow1Mat);
        arrow2.position.y = -0.1;
        dblArrowGroup.add(arrow2);
        
        dblArrowGroup.position.set(0, 0.25, 0.55);
        dblArrowGroup.scale.setScalar(0.7);
        platformGroup.add(dblArrowGroup);
      }

      // Deadly ë°œíŒ: ë°ìŠ¤ í”Œë ˆì´íŠ¸ì™€ ë™ì¼í•œ ë””ìì¸
      if (type === 'deadly') {
        // ë¶‰ì€ ê¸€ë¡œìš° ë ˆì´ì–´ 1 (ê°•í•œ ë¹›)
        const deadlyGlow1 = new THREE.Mesh(
          new THREE.BoxGeometry(width, 0.1, 1.5),
          new THREE.MeshBasicMaterial({
            color: 0xff0000,
            transparent: true,
            opacity: 0.6
          })
        );
        deadlyGlow1.position.y = 0.3;
        platformGroup.add(deadlyGlow1);
        platformGroup.userData.deadlyGlow1 = deadlyGlow1;

        // ë¶‰ì€ ê¸€ë¡œìš° ë ˆì´ì–´ 2 (ì¤‘ê°„ ë¹›)
        const deadlyGlow2 = new THREE.Mesh(
          new THREE.BoxGeometry(width + 0.3, 0.05, 2),
          new THREE.MeshBasicMaterial({
            color: 0xff3300,
            transparent: true,
            opacity: 0.4
          })
        );
        deadlyGlow2.position.y = 0.4;
        platformGroup.add(deadlyGlow2);
        platformGroup.userData.deadlyGlow2 = deadlyGlow2;

        // ë¶‰ì€ ê¸€ë¡œìš° ë ˆì´ì–´ 3 (ì•½í•œ ë¹›, ë„“ì€ ë²”ìœ„)
        const deadlyGlow3 = new THREE.Mesh(
          new THREE.BoxGeometry(width + 0.6, 0.03, 2.5),
          new THREE.MeshBasicMaterial({
            color: 0xff2200,
            transparent: true,
            opacity: 0.2
          })
        );
        deadlyGlow3.position.y = 0.5;
        platformGroup.add(deadlyGlow3);
        platformGroup.userData.deadlyGlow3 = deadlyGlow3;

        // ë¶ˆê½ƒ íŒŒí‹°í´
        const fireCount = 15;
        const fireGeom = new THREE.BufferGeometry();
        const firePositions = new Float32Array(fireCount * 3);
        const fireVelocities = [];
        
        for (let i = 0; i < fireCount; i++) {
          firePositions[i * 3] = (Math.random() - 0.5) * width;
          firePositions[i * 3 + 1] = Math.random() * 0.5;
          firePositions[i * 3 + 2] = (Math.random() - 0.5) * 0.8;
          fireVelocities.push(0.5 + Math.random() * 1);
        }
        
        fireGeom.setAttribute('position', new THREE.BufferAttribute(firePositions, 3));
        const fireMat = new THREE.PointsMaterial({
          color: 0xff4400,
          size: 0.15,
          transparent: true,
          opacity: 0.7
        });
        const fireParticles = new THREE.Points(fireGeom, fireMat);
        platformGroup.add(fireParticles);
        platformGroup.userData.fireParticles = fireParticles;
        platformGroup.userData.fireVelocities = fireVelocities;
      }

      const label = document.createElement('span');
      label.className = 'platform-label';
      platformLabelsContainer.appendChild(label);

      const platformId = platformIdCounter++;

      platformGroup.userData = {
        ...platformGroup.userData,
        id: platformId,
        type, special, originalX: x,
        amplitude: type === 'start' ? 0 : 2 + Math.random(),
        speed: type === 'start' ? 0 : 1 + Math.random(),
        phase: Math.random() * Math.PI * 2,
        prevX: x, deltaX: 0, label, vanishStarted: false, falling: false,
        platformMesh: platformMesh
      };
      scene.add(platformGroup); platforms.push(platformGroup);
    }

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // ì°©ì§€ íŒŒí‹°í´ ì‹œìŠ¤í…œ
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    const landingParticles = [];
    
    function createLandingParticles(x, y, color) {
      const particleCount = 12;
      const particles = [];
      
      for (let i = 0; i < particleCount; i++) {
        const angle = (i / particleCount) * Math.PI * 2 + Math.random() * 0.3;
        const speed = 0.08 + Math.random() * 0.08;
        
        const particle = new THREE.Mesh(
          new THREE.SphereGeometry(0.08, 8, 8),
          new THREE.MeshBasicMaterial({
            color: color,
            transparent: true,
            opacity: 1
          })
        );
        
        particle.position.set(x, y + 0.3, 0);
        particle.userData = {
          vx: Math.cos(angle) * speed,
          vy: 0.1 + Math.random() * 0.05,
          vz: Math.sin(angle) * speed * 0.3,
          life: 1.0
        };
        
        scene.add(particle);
        particles.push(particle);
      }
      
      landingParticles.push(...particles);
    }
    
    function updateLandingParticles() {
      for (let i = landingParticles.length - 1; i >= 0; i--) {
        const p = landingParticles[i];
        
        // ìœ„ì¹˜ ì—…ë°ì´íŠ¸
        p.position.x += p.userData.vx;
        p.position.y += p.userData.vy;
        p.position.z += p.userData.vz;
        
        // ì¤‘ë ¥
        p.userData.vy -= 0.008;
        
        // ìˆ˜ëª… ê°ì†Œ
        p.userData.life -= 0.03;
        p.material.opacity = p.userData.life;
        p.scale.setScalar(p.userData.life);
        
        // ì œê±°
        if (p.userData.life <= 0) {
          scene.remove(p);
          landingParticles.splice(i, 1);
        }
      }
    }

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // í¬ëŸ¼ë¸” ë¶€ì„œì§€ëŠ” íŒŒí¸ ì‹œìŠ¤í…œ
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    const crumbleDebris = [];
    
    function createCrumbleDebris(platform) {
      const debrisCount = 15;
      const px = platform.position.x;
      const py = platform.position.y;
      const width = platform.geometry.parameters.width;
      
      for (let i = 0; i < debrisCount; i++) {
        // ë°œíŒ ìœ„ì—ì„œ ëœë¤ ìœ„ì¹˜
        const offsetX = (Math.random() - 0.5) * width;
        const offsetZ = (Math.random() - 0.5) * 0.8;
        
        // ì‘ì€ ì¡°ê° (0.1~0.2 í¬ê¸°)
        const size = 0.1 + Math.random() * 0.1;
        const debris = new THREE.Mesh(
          new THREE.BoxGeometry(size, size, size),
          new THREE.MeshBasicMaterial({
            color: 0xaa8866,
            transparent: true,
            opacity: 1
          })
        );
        
        debris.position.set(px + offsetX, py + 0.3, offsetZ);
        
        // ëœë¤ ì†ë„
        const angle = Math.random() * Math.PI * 2;
        const speed = 0.05 + Math.random() * 0.1;
        
        debris.userData = {
          vx: Math.cos(angle) * speed,
          vy: 0.15 + Math.random() * 0.1, // ìœ„ë¡œ íŠ€ì–´ì˜¤ë¦„
          vz: Math.sin(angle) * speed * 0.5,
          rotationSpeed: {
            x: (Math.random() - 0.5) * 0.2,
            y: (Math.random() - 0.5) * 0.2,
            z: (Math.random() - 0.5) * 0.2
          },
          life: 1.0
        };
        
        scene.add(debris);
        crumbleDebris.push(debris);
      }
    }
    
    function updateCrumbleDebris() {
      for (let i = crumbleDebris.length - 1; i >= 0; i--) {
        const d = crumbleDebris[i];
        
        // ìœ„ì¹˜ ì—…ë°ì´íŠ¸
        d.position.x += d.userData.vx;
        d.position.y += d.userData.vy;
        d.position.z += d.userData.vz;
        
        // íšŒì „ (tumbling)
        d.rotation.x += d.userData.rotationSpeed.x;
        d.rotation.y += d.userData.rotationSpeed.y;
        d.rotation.z += d.userData.rotationSpeed.z;
        
        // ì¤‘ë ¥
        d.userData.vy -= 0.01;
        
        // ìˆ˜ëª… ê°ì†Œ
        d.userData.life -= 0.02;
        d.material.opacity = d.userData.life;
        
        // ì œê±°
        if (d.userData.life <= 0) {
          scene.remove(d);
          crumbleDebris.splice(i, 1);
        }
      }
    }

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // Death plate
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    let deathPlate, deathGlow1, deathGlow2, deathGlow3, fireParticles, fireParticleVelocities;
    const fireParticleCount = 50;

    function createDeathPlate() {
      deathPlate = new THREE.Mesh(
        new THREE.BoxGeometry(400, 0.5, 2),
        new THREE.MeshBasicMaterial({ color: 0x000000 })
      );
      deathPlate.position.set(0, -15, 0); // ë” ì•„ë˜ì—ì„œ ì‹œì‘
      scene.add(deathPlate);

      deathGlow1 = new THREE.Mesh(
        new THREE.BoxGeometry(400, 0.1, 3),
        new THREE.MeshBasicMaterial({
          color: 0xff0000,
          transparent: true,
          opacity: 0.6
        })
      );
      deathGlow1.position.y = 0.3;
      deathPlate.add(deathGlow1);

      deathGlow2 = new THREE.Mesh(
        new THREE.BoxGeometry(400, 0.05, 5),
        new THREE.MeshBasicMaterial({
          color: 0xff3300,
          transparent: true,
          opacity: 0.4
        })
      );
      deathGlow2.position.y = 0.5;
      deathPlate.add(deathGlow2);

      deathGlow3 = new THREE.Mesh(
        new THREE.BoxGeometry(400, 0.03, 8),
        new THREE.MeshBasicMaterial({
          color: 0xff2200,
          transparent: true,
          opacity: 0.2
        })
      );
      deathGlow3.position.y = 0.7;
      deathPlate.add(deathGlow3);

      const fireParticleGeom = new THREE.BufferGeometry();
      const fireParticlePositions = new Float32Array(fireParticleCount * 3);
      fireParticleVelocities = new Float32Array(fireParticleCount);

      for (let i = 0; i < fireParticleCount; i++) {
        fireParticlePositions[i * 3] = (Math.random() - 0.5) * 20;
        fireParticlePositions[i * 3 + 1] = Math.random() * 2;
        fireParticlePositions[i * 3 + 2] = (Math.random() - 0.5) * 2;
        fireParticleVelocities[i] = 0.5 + Math.random() * 1.5;
      }
      fireParticleGeom.setAttribute('position', new THREE.BufferAttribute(fireParticlePositions, 3));
      const fireParticleMat = new THREE.PointsMaterial({
        color: 0xff4400,
        size: 0.3,
        transparent: true,
        opacity: 0.7
      });
      fireParticles = new THREE.Points(fireParticleGeom, fireParticleMat);
      deathPlate.add(fireParticles);
    }

    let maxY = 0;
    let nextPlatformY = 30;

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // Main loop
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    function animate() {
      animationId = requestAnimationFrame(animate);
      const delta = clock.getDelta();
      const elapsed = clock.getElapsedTime();

      // íƒ€ì´í‹€ í™”ë©´
      if (gameState === 'title' || gameState === 'countdown') {
        // íƒ€ì´í‹€ì¼ ë•Œë§Œ ë¸”ë™í™€ ê¸°ë³¸ ì• ë‹ˆë©”ì´ì…˜ (ì¹´ìš´íŠ¸ë‹¤ìš´ ì¤‘ì—ëŠ” animateSuctionì´ ì²˜ë¦¬)
        if (gameState === 'title') {
          updateTitleBlackhole(elapsed);
        }
        
        // ë³„ ë°˜ì§ì„
        starsMaterial.size = 0.5 + Math.sin(elapsed * 2) * 0.1;
        
        renderer.render(scene, camera);
        return;
      }

      // Ready ìƒíƒœ (ì¬ì‹œì‘ ëŒ€ê¸°)
      if (gameState === 'ready') {
        // ë°œíŒ ì• ë‹ˆë©”ì´ì…˜ì€ ê³„ì†
        platforms.forEach(p => {
          if (p.userData.type !== 'start') {
            const dx = p.userData.amplitude * Math.sin(elapsed * p.userData.speed + p.userData.phase);
            p.position.x = p.userData.originalX + dx;
          }
        });
        renderer.render(scene, camera);
        return;
      }

      // ì¼ì‹œì •ì§€
      if (gameState === 'paused') {
        renderer.render(scene, camera);
        return;
      }

      // ê²Œì„ì˜¤ë²„
      if (gameState === 'gameover') {
        renderer.render(scene, camera);
        return;
      }
      
      // ê²Œì„ í´ë¦¬ì–´
      if (gameState === 'clear') {
        renderer.render(scene, camera);
        return;
      }

      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // ê²Œì„ í”Œë ˆì´ ì¤‘
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€


      updateBackground(maxY, elapsed);
      
      // íƒœì–‘ ì—…ë°ì´íŠ¸
      updateSun(maxY, elapsed);
      
      // ë‹¬ ì—…ë°ì´íŠ¸
      updateMoon(maxY, elapsed);
      
      // ì°©ì§€ íŒŒí‹°í´ ì—…ë°ì´íŠ¸
      updateLandingParticles();
      
      // í¬ëŸ¼ë¸” íŒŒí¸ ì—…ë°ì´íŠ¸
      updateCrumbleDebris();

      // Death plate ê¸€ë¡œìš° ì• ë‹ˆë©”ì´ì…˜
      if (deathGlow1) {
        deathGlow1.material.opacity = 0.4 + Math.sin(elapsed * 4) * 0.3;
        deathGlow2.material.opacity = 0.25 + Math.sin(elapsed * 3 + 1) * 0.2;
        deathGlow3.material.opacity = 0.15 + Math.sin(elapsed * 2.5 + 2) * 0.1;

        const firePositions = fireParticles.geometry.attributes.position.array;
        for (let i = 0; i < fireParticleCount; i++) {
          firePositions[i * 3 + 1] += fireParticleVelocities[i] * delta;
          if (firePositions[i * 3 + 1] > 3) {
            firePositions[i * 3 + 1] = 0;
            firePositions[i * 3] = (Math.random() - 0.5) * 20;
          }
        }
        fireParticles.geometry.attributes.position.needsUpdate = true;
        fireParticles.material.opacity = 0.5 + Math.sin(elapsed * 6) * 0.3;
      }

      platforms.forEach(p => {
        p.userData.prevX = p.position.x;
        if (p.userData.type !== 'start' && !p.userData.falling && !isClearSequence) {
          const dx = p.userData.amplitude * Math.sin(elapsed * p.userData.speed + p.userData.phase);
          p.position.x = p.userData.originalX + dx;
        }
        p.userData.deltaX = p.position.x - p.userData.prevX;

        if (p.userData.falling && !isClearSequence) {
          p.position.y -= delta * 50;
          // ë°œíŒ ëª¨ë“  ë©´ íˆ¬ëª…ë„ ì¡°ì ˆ
          if (p.userData.platformMesh && Array.isArray(p.userData.platformMesh.material)) {
            p.userData.platformMesh.material.forEach(mat => {
              mat.opacity = Math.max(0, mat.opacity - delta * 1);
            });
          }
        }

        // SuperBounce ê¸€ë¡œìš° ì• ë‹ˆë©”ì´ì…˜
        if (p.userData.innerGlow) {
          p.userData.innerGlow.material.opacity = 0.4 + Math.sin(elapsed * 5) * 0.3;
          p.userData.innerGlow.rotation.z = elapsed * 2;
        }
        if (p.userData.outerGlow) {
          p.userData.outerGlow.material.opacity = 0.2 + Math.sin(elapsed * 3 + 1) * 0.15;
          p.userData.outerGlow.scale.setScalar(1 + Math.sin(elapsed * 4) * 0.1);
          p.userData.outerGlow.rotation.z = -elapsed * 1.5;
        }
        if (p.userData.sparkles) {
          p.userData.sparkles.material.opacity = 0.5 + Math.sin(elapsed * 8) * 0.4;
          p.userData.sparkles.rotation.y = elapsed * 3;
        }

        // Bounce ê¸€ë¡œìš° ì• ë‹ˆë©”ì´ì…˜
        if (p.userData.bounceGlow) {
          p.userData.bounceGlow.material.opacity = 0.2 + Math.sin(elapsed * 3) * 0.15;
          p.userData.bounceGlow.scale.setScalar(1 + Math.sin(elapsed * 2) * 0.05);
        }

        // Deadly ë°œíŒ ê¸€ë¡œìš° + ë¶ˆê½ƒ ì• ë‹ˆë©”ì´ì…˜
        if (p.userData.deadlyGlow1) {
          p.userData.deadlyGlow1.material.opacity = 0.4 + Math.sin(elapsed * 4) * 0.3;
        }
        if (p.userData.deadlyGlow2) {
          p.userData.deadlyGlow2.material.opacity = 0.25 + Math.sin(elapsed * 3 + 1) * 0.2;
        }
        if (p.userData.deadlyGlow3) {
          p.userData.deadlyGlow3.material.opacity = 0.15 + Math.sin(elapsed * 2.5 + 2) * 0.1;
        }
        if (p.userData.fireParticles) {
          const positions = p.userData.fireParticles.geometry.attributes.position.array;
          const velocities = p.userData.fireVelocities;
          for (let i = 0; i < velocities.length; i++) {
            positions[i * 3 + 1] += velocities[i] * delta;
            if (positions[i * 3 + 1] > 1) {
              positions[i * 3 + 1] = 0;
              positions[i * 3] = (Math.random() - 0.5) * 2.5;
            }
          }
          p.userData.fireParticles.geometry.attributes.position.needsUpdate = true;
          p.userData.fireParticles.material.opacity = 0.5 + Math.sin(elapsed * 6) * 0.3;
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // Crumble ë°œíŒ ì• ë‹ˆë©”ì´ì…˜
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        if (p.userData.type === 'crumble' && p.userData.dust) {
          const dustData = p.userData.dustData;
          const positions = p.userData.dust.geometry.attributes.position.array;
          
          // ì°©ì§€ ë²„ìŠ¤íŠ¸ ì²˜ë¦¬
          if (p.userData.dustBurst) {
            p.userData.dustBurst = false;
            // ëª¨ë“  ë¨¼ì§€ë¥¼ ì¦‰ì‹œ í™œì„±í™”í•˜ê³  ìœ„ë¡œ íŠ€ì–´ì˜¤ë¥´ê²Œ
            for (let i = 0; i < dustData.length; i++) {
              const d = dustData[i];
              d.delay = 0;
              d.active = true;
              d.y = 0.3 + Math.random() * 0.5; // ìœ„ì—ì„œ ì‹œì‘
              d.fallSpeed = 1.5 + Math.random() * 2.0; // ë¹ ë¥´ê²Œ
              // ìƒˆ ìœ„ì¹˜ë¡œ í©ë¿Œë¦¬ê¸° (ë” ë„“ê²Œ)
              const burstWidth = d.dustWidth * 1.2;
              d.baseX = (Math.random() - 0.5) * burstWidth;
              d.baseZ = (Math.random() - 0.5) * 1.5;
              d.resetY = -2.0 - Math.random() * 2.0; // ë” ì•„ë˜ê¹Œì§€
            }
            // ë¨¼ì§€ í¬ê¸°ì™€ íˆ¬ëª…ë„ ì¼ì‹œì  ì¦ê°€
            p.userData.dust.material.size = 0.18;
            p.userData.dust.material.opacity = 0.9;
            p.userData.dustBurstTime = elapsed;
          }
          
          // ë²„ìŠ¤íŠ¸ í›„ ì„œì„œíˆ ì›ë˜ëŒ€ë¡œ
          if (p.userData.dustBurstTime) {
            const burstElapsed = elapsed - p.userData.dustBurstTime;
            if (burstElapsed < 0.5) {
              p.userData.dust.material.size = 0.18 - burstElapsed * 0.12;
              p.userData.dust.material.opacity = 0.9 - burstElapsed * 0.4;
            } else {
              p.userData.dust.material.size = 0.12;
              p.userData.dust.material.opacity = 0.7;
            }
          }
          
          // í‰ì†Œ ë¨¼ì§€ ì• ë‹ˆë©”ì´ì…˜ (ë¶ˆê·œì¹™í•˜ê²Œ ë–¨ì–´ì§)
          for (let i = 0; i < dustData.length; i++) {
            const d = dustData[i];
            
            // ë”œë ˆì´ ì²´í¬
            d.delay -= delta;
            if (d.delay > 0) continue;
            
            d.active = true;
            
            // Y ìœ„ì¹˜ ì—…ë°ì´íŠ¸ (ë–¨ì–´ì§)
            const fallMultiplier = p.userData.crackStartTime ? 2.5 : 1; // ê· ì—´ í›„ ë¹¨ë¼ì§
            d.y -= delta * d.fallSpeed * fallMultiplier;
            
            // X, Z í”ë“¤ë¦¼ (ë” í¬ê²Œ)
            const wobbleX = Math.sin(elapsed * d.wobbleSpeed + d.wobble) * d.wobbleAmount;
            const wobbleZ = Math.cos(elapsed * d.wobbleSpeed * 0.7 + d.wobble) * d.wobbleAmount * 0.7;
            
            positions[i * 3] = d.baseX + wobbleX;
            positions[i * 3 + 1] = d.y;
            positions[i * 3 + 2] = d.baseZ + wobbleZ;
            
            // ë¦¬ì…‹ (ëœë¤ ìœ„ì¹˜ì—ì„œ ì‚¬ë¼ì§)
            if (d.y < d.resetY) {
              // ìƒˆ ì‹œì‘ ìœ„ì¹˜ (ë°œíŒë³´ë‹¤ ë„“ì€ ì˜ì—­)
              const dustWidth = d.dustWidth;
              const edgeBias = Math.random() < 0.6;
              if (edgeBias) {
                const side = Math.random() < 0.5 ? -1 : 1;
                d.baseX = side * (dustWidth / 2 - Math.random() * 0.5);
              } else {
                d.baseX = (Math.random() - 0.5) * dustWidth;
              }
              d.baseZ = (Math.random() - 0.5) * 1.2;
              d.y = 0.3 + Math.random() * 0.3;
              d.delay = Math.random() * (p.userData.crackStartTime ? 0.15 : 0.5); // ë” ë¹ˆë²ˆí•˜ê²Œ
              d.fallSpeed = 0.8 + Math.random() * 1.2;
              d.resetY = -1.5 - Math.random() * 1.5; // ìƒˆ ëœë¤ ì‚¬ë¼ì§ ìœ„ì¹˜
            }
          }
          
          p.userData.dust.geometry.attributes.position.needsUpdate = true;
          
          // ê· ì—´ ì• ë‹ˆë©”ì´ì…˜ (ì°©ì§€ í›„)
          if (p.userData.crackStartTime !== null) {
            const crackElapsed = elapsed - p.userData.crackStartTime;
            const crackDuration = 0.25; // ê· ì—´ í™•ì‚° ì‹œê°„
            
            // ê· ì—´ ì§„í–‰ë„
            p.userData.crackProgress = Math.min(crackElapsed / crackDuration, 1);
            
            // ê° ê· ì—´ ë¼ì¸ ì• ë‹ˆë©”ì´ì…˜
            p.userData.crackLines.forEach((crack, idx) => {
              const delay = crack.isBranch ? 0.1 : idx * 0.03;
              const localProgress = Math.max(0, Math.min((crackElapsed - delay) / (crackDuration - delay), 1));
              
              // íˆ¬ëª…ë„
              crack.line.material.opacity = localProgress * crack.targetOpacity;
              
              // ê· ì—´ í™•ì‚° (ì  ìœ„ì¹˜ ì¡°ì •) - ì„ íƒì 
              if (localProgress > 0 && localProgress < 1) {
                // ì•½ê°„ì˜ í”ë“¤ë¦¼
                crack.line.position.x = (Math.random() - 0.5) * 0.02;
                crack.line.position.z = (Math.random() - 0.5) * 0.01;
              } else {
                crack.line.position.x = 0;
                crack.line.position.z = 0;
              }
            });
            
            // ì¶©ê²© ë§ ì• ë‹ˆë©”ì´ì…˜
            if (p.userData.impactRing) {
              const ringProgress = Math.min(crackElapsed / 0.3, 1);
              p.userData.impactRing.scale.setScalar(1 + ringProgress * 8);
              p.userData.impactRing.material.opacity = 0.8 * (1 - ringProgress);
            }
            
            // ë°œíŒ í”ë“¤ë¦¼ (ê· ì—´ ì§„í–‰ ì¤‘)
            if (p.userData.crackProgress < 1) {
              const shake = Math.sin(elapsed * 50) * 0.03 * p.userData.crackProgress;
              if (p.userData.platformMesh) {
                p.userData.platformMesh.position.x = shake;
              }
            } else {
              // ê· ì—´ ì™„ë£Œ í›„ ì§€ì†ì ì¸ ì‘ì€ í”ë“¤ë¦¼
              const shake = Math.sin(elapsed * 20) * 0.015;
              if (p.userData.platformMesh) {
                p.userData.platformMesh.position.x = shake;
              }
            }
          }
        }

        const label = p.userData.label;
        if (label && label.style.display !== 'none') {
          const pos = p.position.clone().project(camera);
          label.style.left = `${(pos.x + 1) / 2 * window.innerWidth}px`;
          label.style.top = `${(-pos.y + 1) / 2 * window.innerHeight}px`;
        }
      });

      // í”Œë ˆì´ì–´ ëˆˆ ê¹œë¹¡ì„ ì• ë‹ˆë©”ì´ì…˜
      if (player.visible) {
        // ì¶©ì „ ì¤‘ì¼ ë•Œ ì¸ìƒ ì“°ê¸° (ëˆˆ ì°¡ê·¸ë¦¬ê¸°)
        if (isCharging && isGrounded) {
          const squint = 0.3 + (1 - chargeTime / maxCharge) * 0.3; // 0.3~0.6
          leftEyeGroup.scale.y = squint;
          rightEyeGroup.scale.y = squint;
          // ëˆˆ ê°€ë¡œë¡œ ë„“íˆê¸°
          leftEyeGroup.scale.x = 1.2;
          rightEyeGroup.scale.x = 1.2;
          // ëˆˆ ì•ˆìª½ìœ¼ë¡œ ê¸°ìš¸ì´ê¸° (ì°¡ê·¸ë¦¼)
          leftEyeGroup.rotation.z = -0.2;
          rightEyeGroup.rotation.z = 0.2;
        } else {
          // í‰ì†Œ ê¹œë¹¡ì„
          leftEyeGroup.rotation.z = 0;
          rightEyeGroup.rotation.z = 0;
          leftEyeGroup.scale.x = 1;
          rightEyeGroup.scale.x = 1;
          
          nextBlinkTime -= delta;
          
          if (nextBlinkTime <= 0 && !isBlinking) {
            isBlinking = true;
            blinkProgress = 0;
          }
          
          if (isBlinking) {
            blinkProgress += delta * 15; // ê¹œë¹¡ì„ ì†ë„
            
            if (blinkProgress < 1) {
              // ëˆˆ ê°ê¸° (ì„¸ë¡œë¡œ ë‚©ì‘)
              const scaleY = 1 - blinkProgress * 0.9;
              leftEyeGroup.scale.y = scaleY;
              rightEyeGroup.scale.y = scaleY;
            } else if (blinkProgress < 2) {
              // ëˆˆ ëœ¨ê¸°
              const scaleY = 0.1 + (blinkProgress - 1) * 0.9;
              leftEyeGroup.scale.y = scaleY;
              rightEyeGroup.scale.y = scaleY;
            } else {
              // ê¹œë¹¡ì„ ì™„ë£Œ
              leftEyeGroup.scale.y = 1;
              rightEyeGroup.scale.y = 1;
              isBlinking = false;
              
              // ë‹¤ìŒ ê¹œë¹¡ì„ (ìì—°ìŠ¤ëŸ¬ìš´ ëœë¤ ê°„ê²©)
              if (Math.random() < 0.2) {
                nextBlinkTime = 0.15 + Math.random() * 0.2;
              } else {
                nextBlinkTime = 1.5 + Math.random() * 3;
              }
            }
          } else if (!isCharging) {
            // ì¶©ì „ ëë‚˜ë©´ ëˆˆ ì›ë˜ëŒ€ë¡œ
            leftEyeGroup.scale.y = 1;
            rightEyeGroup.scale.y = 1;
          }
        }
      }

      if (isCharging && isGrounded) {
        chargeTime += chargeDirection * delta * chargeSpeed;
        if (chargeTime >= maxCharge) { chargeTime = maxCharge; chargeDirection = -1; }
        else if (chargeTime <= 0) { chargeTime = 0; chargeDirection = 1; }
        chargeFill.style.width = `${(chargeTime / maxCharge) * 100}%`;
        updateChargeSound(chargeTime / maxCharge);
      }

      if (!isGrounded && !isClearSequence) {
        if (input.left) player.position.x -= 0.1;
        if (input.right) player.position.x += 0.1;
        // X ë²”ìœ„ ì œí•œ
        player.position.x = Math.max(-7.5, Math.min(7.5, player.position.x));
      }

      if (!isClearSequence) {
        velocityY += (velocityY > 0) ? -0.02 : -0.006;
        player.position.y += velocityY;
      }

      if (isGrounded && onPlatform && !isClearSequence) player.position.x += onPlatform.userData.deltaX;

      onPlatform = null; isGrounded = false;

      for (let i = platforms.length - 1; i >= 0; i--) {
        const p = platforms[i];
        const w = p.geometry.parameters.width;
        const playerBottomPrev = player.position.y - velocityY - 0.5;
        const playerBottomNow = player.position.y - 0.5;
        const platformTop = p.position.y + 0.25;
        const withinX = Math.abs(player.position.x - p.position.x) < (w / 2 + 0.5);
        const falling = velocityY <= 0;
        const crossed = playerBottomPrev >= platformTop && playerBottomNow <= platformTop;

        if (withinX && crossed && falling && !p.userData.falling) {
          player.position.y = platformTop + 0.5;
          velocityY = 0; isGrounded = true; onPlatform = p;
          
          // ì í”„ ê¸°ë¡ ì¢…ë£Œ
          endJumpRecord();

          const isNewLanding = lastLandedPlatformId !== p.userData.id;
          lastLandedPlatformId = p.userData.id;

          // ì°©ì§€ íŒŒí‹°í´ ìƒì„± (ìƒˆë¡œìš´ ì°©ì§€ì¼ ë•Œë§Œ)
          if (isNewLanding) {
            const particleColor = p.material.color.getHex();
            createLandingParticles(player.position.x, platformTop, particleColor);
          }

          if (isNewLanding) {
            if (p.userData.special === 'deadly') {
              // "ê·¸ê±¸ ë°Ÿë„¤..." í…ìŠ¤íŠ¸ ë„ìš°ê³  ê²Œì„ì˜¤ë²„
              showDeadlyMessage();
              return;
            } else if (p.userData.special === 'bounce') {
              velocityY = maxCharge;
              isGrounded = false;
              lastLandedPlatformId = null;
              playBounceSound();
              startJumpRecord('bounce');
            } else if (p.userData.special === 'superBounce') {
              velocityY = maxCharge * 1.4;
              isGrounded = false;
              lastLandedPlatformId = null;
              playSuperBounceSound();
              startJumpRecord('superBounce');
            } else if (p.userData.special === 'crumble') {
              // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
              // í¬ëŸ¼ë¸”: ê· ì—´ ì‹œì‘!
              // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
              if (p.userData.crackStartTime === null) {
                playCrackSound(); // ì©! ì‚¬ìš´ë“œ
                p.userData.crackStartTime = elapsed;
                p.userData.crackGroup.visible = true;
                p.userData.dustBurst = true; // í’€ì©! ë¨¼ì§€ ë²„ìŠ¤íŠ¸
                
                // 1ì´ˆ í›„ ë¶•ê´´
                setTimeout(() => {
                  p.userData.falling = true;
                  playCrumbleSound();
                  createCrumbleDebris(p);
                }, 1000);
              }
            }
          }

          if (p.userData.special === 'vanish' && !p.userData.vanishStarted) {
            p.userData.vanishStarted = true;
            const label = p.userData.label;
            let seconds = 3;
            if (label) { label.style.display = 'block'; label.innerText = seconds; }
            const interval = setInterval(() => {
              seconds--;
              if (seconds <= 0) {
                clearInterval(interval);
                label?.remove?.();
                p.userData.falling = true;
              } else if (label) { label.innerText = seconds; }
            }, 1000);
          }
          break;
        }
      }

      // í´ë¦¬ì–´ ì‹œí€€ìŠ¤ ì¤‘ì—ëŠ” ì¹´ë©”ë¼ Y ê³ ì •
      if (!isClearSequence) {
        if (player.position.y > camera.position.y - 3) camera.position.y = player.position.y + 3;
      }
      if (player.position.y > maxY) maxY = player.position.y;
      scoreEl.innerText = `Score: ${Math.floor(maxY)}`;
      
      // í´ë¦¬ì–´ ì¡°ê±´ ì²´í¬ (2500ì ) - ë¬´í•œëª¨ë“œë©´ ê±´ë„ˆëœ€
      if (!isInfiniteMode && maxY >= CLEAR_HEIGHT && !isClearSequence) {
        isClearSequence = true;
        clearSequenceStart = elapsed;
        finalScoreValue = Math.floor(maxY);
        
        // ì¹´ë©”ë¼ ê¸°ì¤€ ë¸”ë™í™€ ìƒëŒ€ ì¢Œí‘œ (ê³ ì •ê°’)
        // ì¹´ë©”ë¼: (0, camY, 10)
        // ë¸”ë™í™€: (10, camY - 8, -20)
        const camY = camera.position.y;
        clearTargetPos = new THREE.Vector3(10, camY - 8, -20);
        
        // ë¸”ë™í™€ ìœ„ì¹˜ë„ ë§ì¶¤
        blackholeGroup.position.copy(clearTargetPos);
        
        // ë¸”ë™í™€ í™”ë©´ ì¢Œí‘œë„ ì €ì¥ (ê³ ì •)
        const bhScreenPos = clearTargetPos.clone().project(camera);
        clearScreenX = (bhScreenPos.x + 1) / 2 * window.innerWidth;
        clearScreenY = (-bhScreenPos.y + 1) / 2 * window.innerHeight;
        
        // Death plate ìˆ¨ê¸°ê¸°
        if (deathPlate) deathPlate.visible = false;
      }

      while (nextPlatformY < maxY + 30) {
        const type = getRandomPlatformType();
        createPlatform((Math.random() - 0.5) * 5, nextPlatformY, type);

        const a = 0.002, b = DIFFICULTY_CENTER;
        const difficultyScale = 1 / (1 + Math.exp(-a * (maxY - b)));
        const baseGap = 3, maxGap = 6;
        const gap = baseGap + (maxGap - baseGap) * difficultyScale;
        const baseJitter = 0.2, maxJitter = 2.0;
        const jitter = baseJitter + (maxJitter - baseJitter) * difficultyScale;
        nextPlatformY += gap + (Math.random() * 2 - 1) * jitter;
      }

      // Death plate ì´ë™ (ë” ì•„ë˜ì—ì„œ ìŠ¤í°)
      if (deathPlate && !isClearSequence) {
        // ì†ë„: 2ì—ì„œ ì‹œì‘, DEATHPLATE_MAX_SPEED_HEIGHTì—ì„œ 4ê¹Œì§€ (ì œê³± ê³¡ì„ ìœ¼ë¡œ ê°€ì†)
        const speedProgress = Math.min(maxY / DEATHPLATE_MAX_SPEED_HEIGHT, 1);
        const deathPlateSpeed = 2 + 2 * speedProgress * speedProgress;
        deathPlate.position.y += delta * deathPlateSpeed;
        
        if (player.position.y - deathPlate.position.y > 26) {
          deathPlate.position.y = player.position.y - 26;
        }

        const plateTop = deathPlate.position.y + 0.25;
        const playerBottom = player.position.y - 0.5;
        // ì „ì²´ X ë²”ìœ„ì—ì„œ íŒì • (ë²„ê·¸ ìˆ˜ì •)
        const hitDeathPlate = !isInvincible && playerBottom <= plateTop;

        if (hitDeathPlate) {
          gameOver();
          return;
        }
      }

      // ë°œíŒ ì œê±° (ì¹´ë©”ë¼ ì•„ë˜ ë˜ëŠ” Death plate ë†’ì´)
      for (let i = platforms.length - 1; i >= 0; i--) {
        const p = platforms[i];
        const platformBottom = p.position.y - 0.25;
        const shouldRemove = p.position.y < camera.position.y - 40 || 
                            (deathPlate && platformBottom <= deathPlate.position.y + 0.25);
        if (shouldRemove) {
          p.userData.label?.remove?.();
          scene.remove(p);
          platforms.splice(i, 1);
        }
      }

      // í´ë¦¬ì–´ ì‹œí€€ìŠ¤ ì—…ë°ì´íŠ¸
      if (isClearSequence) {
        const shouldStop = updateClearSequence(elapsed, delta);
        if (shouldStop) {
          renderer.render(scene, camera);
          return;
        }
      }

      renderer.render(scene, camera);
    }

    let deadlyDeath = false;

    function showDeadlyMessage() {
      deadlyDeath = true;
      playDeadlySound();
      gameOver();
    }

    function gameOver() {
      gameState = 'gameover';
      
      // ê²€ì€ ë°œíŒ ì‚¬ë§ ì‹œ ì œëª© ë³€ê²½ - ì´ìŠ¤í„°ì—ê·¸!
      const gameOverTitle = document.getElementById('gameOverTitle');
      if (deadlyDeath && gameOverTitle) {
        gameOverTitle.innerHTML = 'ğŸ‰ EASTER EGG! ğŸ‰<br><span style="font-size:18px;">You found the Petite Death Platform!</span>';
        gameOverTitle.style.color = '#fff';
        gameOverTitle.style.background = 'linear-gradient(135deg, #ff6b6b, #feca57, #48dbfb, #ff9ff3, #54a0ff)';
        gameOverTitle.style.backgroundSize = '300% 300%';
        gameOverTitle.style.animation = 'rainbow 2s ease infinite';
        gameOverTitle.style.padding = '15px 25px';
        gameOverTitle.style.borderRadius = '15px';
        gameOverTitle.style.textShadow = '2px 2px 4px rgba(0,0,0,0.3)';
        gameOverTitle.style.boxShadow = '0 0 30px rgba(255,200,100,0.8), 0 0 60px rgba(255,100,200,0.5)';
      }
      
      const score = Math.floor(maxY);
      finalScoreText.innerText = `Your Score: ${score}`;
      gameOverScreen.style.display = 'block';

      stopChargeSound();
      stopBlackholeDrone();
      playGameOverSound();

      finalScoreValue = score;

      (async () => {
        const serverData = await fetchServerLeaderboard(10);
        if (!renderServerLeaderboardData(serverData)) {
          leaderboardList.innerHTML = '<li style="color:#ff6666;">ì„œë²„ ì—°ê²° ì‹¤íŒ¨</li>';
        }
      })();

      playerNameInput && setTimeout(() => playerNameInput.focus(), 0);
      enableSaveButtonIfReady();
    }

    animate();
  </script>
</body>

</html>
