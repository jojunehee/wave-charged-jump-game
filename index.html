<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <title>Wave Charged Jump Game (v2.0)</title>
  <style>
    html,
    body {
      height: 100%;
      touch-action: none;
    }

    body {
      margin: 0;
      overflow: hidden;
    }

    canvas {
      display: block;
    }

    #score {
      position: absolute;
      top: 10px;
      left: 10px;
      font-size: 24px;
      background: rgba(255, 255, 255, 0.7);
      padding: 6px 10px;
      border-radius: 8px;
      z-index: 10;
      user-select: none;
    }

    #chargeBar {
      position: absolute;
      bottom: 10px;
      left: 50%;
      transform: translateX(-50%);
      width: min(80vw, 800px);
      height: 20px;
      background: #ddd;
      border-radius: 10px;
      overflow: hidden;
      z-index: 11;
    }

    #chargeFill {
      height: 100%;
      background: red;
      width: 0%;
    }

    #gameOverScreen {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 0, 0, 0.8);
      color: white;
      padding: 30px;
      border-radius: 12px;
      display: none;
      text-align: center;
      z-index: 20;
      min-width: 320px;
    }

    #platformLabelsContainer {
      position: absolute;
      top: 0;
      left: 0;
      pointer-events: none;
      z-index: 15;
    }

    .platform-label {
      position: absolute;
      font-size: 20px;
      font-weight: bold;
      color: black;
      text-shadow: 1px 1px white;
      transform: translate(-50%, -50%);
      display: none;
    }
  </style>
</head>

<body>
  <div id="score">Score: 0</div>
  <div id="chargeBar">
    <div id="chargeFill"></div>
  </div>

  <div id="gameOverScreen">
    <h1>Game Over</h1>
    <p id="finalScoreText"></p>

    <div style="margin-top:12px;">
      <input id="playerNameInput" type="text" maxlength="24" placeholder="Your name"
        style="padding:8px;border-radius:6px;border:1px solid #ccc;width:220px;">
      <button id="submitScoreBtn" disabled
        style="padding:8px 12px;border-radius:6px;border:0;background:#4CAF50;color:#fff;cursor:pointer;opacity:0.6;">
        Save Score
      </button>
      <div id="nameHint" style="margin-top:6px;font-size:12px;color:#ffb300;display:none;">
        이름이 없으면 'noname'으로 저장할지 확인합니다.
      </div>
    </div>

    <div style="margin-top:10px;">
      <button id="playAgainBtn">Play Again</button>
    </div>

    <div id="leaderboard" style="margin-top:18px;text-align:left;max-width:360px;margin-left:auto;margin-right:auto;">
      <h2 style="margin:6px 0 8px;">Leaderboard</h2>
      <ol id="leaderboardList" style="padding-left:18px;margin:0;"></ol>
    </div>
  </div>

  <div id="platformLabelsContainer"></div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>
  <script type="module">
    import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.module.js';

    // ─────────────────────────────────────
    // Sound Effects (Tone.js)
    // ─────────────────────────────────────
    let audioStarted = false;
    const synth = new Tone.Synth().toDestination();
    const membraneSynth = new Tone.MembraneSynth().toDestination();
    
    let chargeOsc = null;

    async function startAudio() {
      if (!audioStarted) {
        await Tone.start();
        audioStarted = true;
      }
    }

    function startChargeSound() {
      if (!audioStarted) return;
      if (chargeOsc) return;
      chargeOsc = new Tone.Oscillator({
        frequency: 200,
        type: "sine",
        volume: -15
      }).toDestination();
      chargeOsc.start();
    }

    function updateChargeSound(chargeRatio) {
      if (chargeOsc) {
        chargeOsc.frequency.value = 200 + chargeRatio * 600;
      }
    }

    function stopChargeSound() {
      if (chargeOsc) {
        chargeOsc.stop();
        chargeOsc.dispose();
        chargeOsc = null;
      }
    }

    function playJumpSound() {
      if (!audioStarted) return;
      synth.triggerAttackRelease("E6", "0.05");
    }

    function playLandSound() {
      if (!audioStarted) return;
      synth.triggerAttackRelease("G3", "0.03");
    }

    function playBounceSound() {
      if (!audioStarted) return;
      synth.triggerAttackRelease("G5", "0.1");
    }

    function playSuperBounceSound() {
      if (!audioStarted) return;
      synth.triggerAttackRelease("B5", "0.15");
      setTimeout(() => synth.triggerAttackRelease("E6", "0.1"), 50);
    }

    function playCrumbleSound() {
      if (!audioStarted) return;
      membraneSynth.triggerAttackRelease("C2", "0.2");
    }

    function playGameOverSound() {
      if (!audioStarted) return;
      synth.triggerAttackRelease("C3", "0.3");
    }

    function playSaveSound() {
      if (!audioStarted) return;
      synth.triggerAttackRelease("E5", "0.1");
      setTimeout(() => synth.triggerAttackRelease("G5", "0.1"), 100);
    }

    // ─────────────────────────────────────
    // 배경 설정
    // ─────────────────────────────────────
    const SKY_NIGHT_HEIGHT = 800;
    const STARS_START_HEIGHT = 400;
    const BLACKHOLE_START_HEIGHT = 1500;
    const CLOUDS_FADE_HEIGHT = SKY_NIGHT_HEIGHT / 2; // 구름이 사라지는 높이 (400)

    const PLATFORM_TYPE_POOL = [
      'normal', 'normal', 'normal', 'normal', 'normal',
      'narrow', 'narrow', 'narrow',
      'bounce', 'bounce',
      'vanish',
      'crumble',
      'superBounce'
    ];

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xd0f0ff);

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 5, 10);
    camera.lookAt(0, 0, 0);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    document.body.appendChild(renderer.domElement);

    window.addEventListener('resize', () => {
      const w = window.innerWidth, h = window.innerHeight;
      renderer.setSize(w, h);
      camera.aspect = w / h;
      camera.updateProjectionMatrix();
    });

    const clock = new THREE.Clock();
    let animationId;

    // ─────────────────────────────────────
    // 별 생성
    // ─────────────────────────────────────
    const starsGeometry = new THREE.BufferGeometry();
    const starCount = 500;
    const starPositions = new Float32Array(starCount * 3);
    
    for (let i = 0; i < starCount; i++) {
      starPositions[i * 3] = (Math.random() - 0.5) * 100;
      starPositions[i * 3 + 1] = Math.random() * 500 + 50;
      starPositions[i * 3 + 2] = -20 - Math.random() * 30;
    }
    
    starsGeometry.setAttribute('position', new THREE.BufferAttribute(starPositions, 3));
    const starsMaterial = new THREE.PointsMaterial({
      color: 0xffffff,
      size: 0.5,
      transparent: true,
      opacity: 0
    });
    const stars = new THREE.Points(starsGeometry, starsMaterial);
    scene.add(stars);

    // ─────────────────────────────────────
    // 구름 생성
    // ─────────────────────────────────────
    const cloudsGroup = new THREE.Group();
    const cloudMaterial = new THREE.MeshBasicMaterial({
      color: 0xffffff,
      transparent: true,
      opacity: 0.7
    });

    // 여러 개의 구름 생성
    const clouds = [];
    for (let i = 0; i < 15; i++) {
      const cloud = new THREE.Group();
      
      // 각 구름은 여러 개의 구체로 구성
      const puffCount = 4 + Math.floor(Math.random() * 4);
      for (let j = 0; j < puffCount; j++) {
        const puffSize = 1.5 + Math.random() * 2;
        const puff = new THREE.Mesh(
          new THREE.SphereGeometry(puffSize, 16, 16),
          cloudMaterial.clone()
        );
        puff.position.x = (j - puffCount / 2) * 1.5 + (Math.random() - 0.5);
        puff.position.y = (Math.random() - 0.5) * 1;
        puff.position.z = (Math.random() - 0.5) * 1;
        puff.scale.y = 0.6; // 납작하게
        cloud.add(puff);
      }
      
      // 구름 위치 설정
      cloud.position.x = (Math.random() - 0.5) * 60;
      cloud.position.y = i * 30 + Math.random() * 20;
      cloud.position.z = -15 - Math.random() * 20;
      cloud.userData = {
        baseY: cloud.position.y,
        driftSpeed: 0.3 + Math.random() * 0.5,
        driftPhase: Math.random() * Math.PI * 2
      };
      
      clouds.push(cloud);
      cloudsGroup.add(cloud);
    }
    scene.add(cloudsGroup);

    // ─────────────────────────────────────
    // 블랙홀 생성 (인터스텔라 스타일)
    // ─────────────────────────────────────
    const blackholeGroup = new THREE.Group();

    // 블랙홀 중심 (완전한 검은 원)
    const blackholeCore = new THREE.Mesh(
      new THREE.CircleGeometry(5, 64),
      new THREE.MeshBasicMaterial({ color: 0x000000 })
    );
    blackholeGroup.add(blackholeCore);

    // 이벤트 호라이즌 (빛나는 테두리)
    const eventHorizonGeometry = new THREE.RingGeometry(4.8, 5.5, 64);
    const eventHorizonMaterial = new THREE.MeshBasicMaterial({
      color: 0xffd700,
      transparent: true,
      opacity: 0.9,
      side: THREE.DoubleSide
    });
    const eventHorizon = new THREE.Mesh(eventHorizonGeometry, eventHorizonMaterial);
    blackholeGroup.add(eventHorizon);

    // 강착 원반 (Accretion Disk) - 여러 층
    const diskColors = [0xff4500, 0xff6600, 0xff8c00, 0xffa500, 0xffd700];
    const diskLayers = [];

    for (let i = 0; i < 5; i++) {
      const innerRadius = 6 + i * 2;
      const outerRadius = 8 + i * 2;
      const diskGeometry = new THREE.RingGeometry(innerRadius, outerRadius, 64);
      const diskMaterial = new THREE.MeshBasicMaterial({
        color: diskColors[i],
        transparent: true,
        opacity: 0.6 - i * 0.1,
        side: THREE.DoubleSide
      });
      const disk = new THREE.Mesh(diskGeometry, diskMaterial);
      disk.rotation.x = Math.PI * 0.3;
      diskLayers.push({ mesh: disk, speed: 0.01 + i * 0.005 });
      blackholeGroup.add(disk);
    }

    // 광자 구체 (Photon Sphere)
    const photonSphereGeometry = new THREE.RingGeometry(5.5, 6, 64);
    const photonSphereMaterial = new THREE.MeshBasicMaterial({
      color: 0xffffff,
      transparent: true,
      opacity: 0.3,
      side: THREE.DoubleSide
    });
    const photonSphere = new THREE.Mesh(photonSphereGeometry, photonSphereMaterial);
    blackholeGroup.add(photonSphere);

    // 외곽 글로우
    const glowLayers = [];
    for (let i = 0; i < 3; i++) {
      const glowGeometry = new THREE.RingGeometry(16 + i * 3, 18 + i * 3, 64);
      const glowMaterial = new THREE.MeshBasicMaterial({
        color: 0xff6600,
        transparent: true,
        opacity: 0.15 - i * 0.04,
        side: THREE.DoubleSide
      });
      const glow = new THREE.Mesh(glowGeometry, glowMaterial);
      glowLayers.push(glow);
      blackholeGroup.add(glow);
    }

    // 빨려들어가는 파티클
    const particleCount = 100;
    const particleGeometry = new THREE.BufferGeometry();
    const particlePositions = new Float32Array(particleCount * 3);
    const particleAngles = new Float32Array(particleCount);
    const particleRadii = new Float32Array(particleCount);

    for (let i = 0; i < particleCount; i++) {
      particleAngles[i] = Math.random() * Math.PI * 2;
      particleRadii[i] = 8 + Math.random() * 15;
      particlePositions[i * 3] = Math.cos(particleAngles[i]) * particleRadii[i];
      particlePositions[i * 3 + 1] = Math.sin(particleAngles[i]) * particleRadii[i];
      particlePositions[i * 3 + 2] = (Math.random() - 0.5) * 5;
    }

    particleGeometry.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));
    const particleMaterial = new THREE.PointsMaterial({
      color: 0xffaa00,
      size: 0.3,
      transparent: true,
      opacity: 0.8
    });
    const blackholeParticles = new THREE.Points(particleGeometry, particleMaterial);
    blackholeGroup.add(blackholeParticles);

    blackholeGroup.position.set(0, 200, -50);
    blackholeGroup.visible = false;
    scene.add(blackholeGroup);

    // ─────────────────────────────────────
    // 배경 업데이트 함수
    // ─────────────────────────────────────
    function getBackgroundColor(t) {
      let r, g, b;
      
      if (t < 0.5) {
        // 하늘색 → 보라/남색
        const p = t / 0.5;
        r = Math.floor(208 - 148 * p);           // 208 → 60
        g = Math.floor(240 - 220 * p);           // 240 → 20
        b = Math.floor(255 - 75 * p);            // 255 → 180
      } else {
        // 보라/남색 → 옅은 보라빛 검정
        const p = (t - 0.5) / 0.5;
        r = Math.floor(60 - 45 * p);             // 60 → 15
        g = Math.floor(20 - 15 * p);             // 20 → 5
        b = Math.floor(180 - 140 * p);           // 180 → 40
      }
      
      return { r, g, b };
    }

    function updateBackground(height, elapsed) {
      // 1. 배경색 변화 (로그 함수로 초반 빠르게, 후반 천천히)
      const t = Math.min(Math.log(1 + height / 200) / Math.log(1 + SKY_NIGHT_HEIGHT / 200), 1);
      const { r, g, b } = getBackgroundColor(t);
      scene.background = new THREE.Color(`rgb(${r},${g},${b})`);
      
      // 2. 별 나타나기
      if (height > STARS_START_HEIGHT) {
        const starOpacity = Math.min((height - STARS_START_HEIGHT) / 50, 1);
        starsMaterial.opacity = starOpacity;
        stars.position.y = camera.position.y - 100;
      } else {
        starsMaterial.opacity = 0;
      }
      
      // 2.5. 구름 업데이트
      const cloudOpacity = Math.max(0, 1 - (height / CLOUDS_FADE_HEIGHT));
      clouds.forEach(cloud => {
        // 구름 투명도 조절
        cloud.children.forEach(puff => {
          puff.material.opacity = 0.7 * cloudOpacity;
        });
        
        // 구름이 카메라를 따라 올라가면서 약간 흔들림
        cloud.position.y = cloud.userData.baseY + camera.position.y * 0.3;
        cloud.position.x += Math.sin(clock.getElapsedTime() * cloud.userData.driftSpeed + cloud.userData.driftPhase) * 0.01;
      });
      
      // 구름 그룹 표시/숨김
      cloudsGroup.visible = cloudOpacity > 0;
      
      // 3. 블랙홀 나타나기 + 애니메이션
      if (height > BLACKHOLE_START_HEIGHT) {
        blackholeGroup.visible = true;
        const bhOpacity = Math.min((height - BLACKHOLE_START_HEIGHT) / 50, 1);
        
        // 이벤트 호라이즌 펄스
        eventHorizonMaterial.opacity = (0.7 + Math.sin(elapsed * 3) * 0.2) * bhOpacity;
        
        // 강착 원반 회전 (각 층마다 다른 속도)
        diskLayers.forEach((layer, i) => {
          layer.mesh.rotation.z += layer.speed;
          layer.mesh.material.opacity = (0.6 - i * 0.1) * bhOpacity;
        });
        
        // 광자 구체 반짝임
        photonSphereMaterial.opacity = (0.2 + Math.sin(elapsed * 5) * 0.1) * bhOpacity;
        
        // 글로우 업데이트
        glowLayers.forEach((glow, i) => {
          glow.material.opacity = (0.15 - i * 0.04) * bhOpacity;
        });
        
        // 파티클 빨려들어가는 애니메이션
        const positions = blackholeParticles.geometry.attributes.position.array;
        for (let i = 0; i < particleCount; i++) {
          particleAngles[i] += 0.02 + (20 - particleRadii[i]) * 0.002;
          particleRadii[i] -= 0.05;
          if (particleRadii[i] < 5) {
            particleRadii[i] = 8 + Math.random() * 15;
          }
          positions[i * 3] = Math.cos(particleAngles[i]) * particleRadii[i];
          positions[i * 3 + 1] = Math.sin(particleAngles[i]) * particleRadii[i];
        }
        blackholeParticles.geometry.attributes.position.needsUpdate = true;
        particleMaterial.opacity = 0.8 * bhOpacity;
        
        blackholeGroup.position.y = camera.position.y + 10;
        blackholeGroup.rotation.z += 0.002;
      } else {
        blackholeGroup.visible = false;
      }
    }

    // ─────────────────────────────────────
    // UI
    // ─────────────────────────────────────
    const scoreEl = document.getElementById('score');
    const chargeFill = document.getElementById('chargeFill');
    const finalScoreText = document.getElementById('finalScoreText');
    const gameOverScreen = document.getElementById('gameOverScreen');
    const platformLabelsContainer = document.getElementById('platformLabelsContainer');
    const playerNameInput = document.getElementById('playerNameInput');
    const submitScoreBtn = document.getElementById('submitScoreBtn');
    const playAgainBtn = document.getElementById('playAgainBtn');
    const leaderboardList = document.getElementById('leaderboardList');
    const nameHint = document.getElementById('nameHint');

    // ─────────────────────────────────────
    // 서버 API 연결
    // ─────────────────────────────────────
    const API_BASE =
      (location.hostname === 'localhost' || location.hostname === '127.0.0.1')
        ? 'http://localhost:8080'
        : 'https://wave-charged-jump-game.onrender.com';

    setInterval(async () => {
      try {
        await fetch(`${API_BASE}/api/scores/top?limit=1`);
      } catch (e) { /* 무시 */ }
    }, 10 * 60 * 1000);

    async function postServerScore(name, score) {
      try {
        const res = await fetch(`${API_BASE}/api/scores`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ name, score })
        });
        if (!res.ok) throw new Error('post failed');
        return await res.json();
      } catch (e) {
        console.warn('server score post failed:', e);
        return null;
      }
    }

    async function fetchServerLeaderboard(limit = 10) {
      try {
        const res = await fetch(`${API_BASE}/api/scores/top?limit=${limit}`, { method: 'GET' });
        if (!res.ok) throw new Error('fetch failed');
        return await res.json();
      } catch (e) {
        console.warn('server leaderboard fetch failed:', e);
        return null;
      }
    }

    function renderServerLeaderboardData(data) {
      if (!data || !Array.isArray(data.items)) return false;
      leaderboardList.innerHTML = '';
      data.items.forEach(item => {
        const li = document.createElement('li');
        li.textContent = `${item.name} — ${item.score}`;
        leaderboardList.appendChild(li);
      });
      return true;
    }

    // ─────────────────────────────────────
    // Game state
    // ─────────────────────────────────────
    const startTime = Date.now();
    let isInvincible = true;
    let velocityY = 0, isGrounded = false, onPlatform = null;
    let chargeTime = 0, isCharging = false, chargeDirection = 1;
    const maxCharge = 1.0, chargeSpeed = 0.8;
    let touchActive = false, touchMode = null, touchStartX = 0, touchLastX = 0, passedDeadzone = false;
    const DRAG_GAIN = 0.01, DEADZONE_PX = 8, MIN_JUMP = 0.2;

    let hasSavedThisGame = false;
    let finalScoreValue = 0;
    
    // 현재 서있는 발판 ID 추적 (소리 중복 방지)
    let lastLandedPlatformId = null;

    // Player
    const player = new THREE.Mesh(
      new THREE.BoxGeometry(1, 1, 1),
      new THREE.MeshBasicMaterial({ color: 0x0000ff })
    );
    scene.add(player);
    player.position.y = 0;

    // Keyboard
    const input = { left: false, right: false };
    document.addEventListener('keydown', async e => {
      if (e.code === 'KeyA' || e.code === 'ArrowLeft') input.left = true;
      if (e.code === 'KeyD' || e.code === 'ArrowRight') input.right = true;
      if (e.code === 'Space' && isGrounded && !isCharging) {
        await startAudio();
        isCharging = true;
        startChargeSound();
      }
    });
    document.addEventListener('keyup', e => {
      if (e.code === 'KeyA' || e.code === 'ArrowLeft') input.left = false;
      if (e.code === 'KeyD' || e.code === 'ArrowRight') input.right = false;
      if (e.code === 'Space' && isCharging) {
        stopChargeSound();
        if (isGrounded) {
          velocityY = Math.max(chargeTime, MIN_JUMP);
          isGrounded = false;
          lastLandedPlatformId = null; // 점프하면 리셋
          playJumpSound();
        }
        chargeTime = 0; isCharging = false; chargeDirection = 1;
        chargeFill.style.width = '0%';
      }
    });

    function enableSaveButtonIfReady() {
      const hasName = !!(playerNameInput?.value.trim());
      if (submitScoreBtn) {
        submitScoreBtn.disabled = !hasName || hasSavedThisGame;
        submitScoreBtn.style.opacity = submitScoreBtn.disabled ? '0.6' : '1';
      }
    }

    async function saveToServer(name, score) {
      if (hasSavedThisGame) return true;

      const result = await postServerScore(name, score);
      if (!result) {
        alert('서버 저장에 실패했습니다. 다시 시도해주세요.');
        return false;
      }

      hasSavedThisGame = true;
      if (submitScoreBtn) {
        submitScoreBtn.disabled = true;
        submitScoreBtn.textContent = 'Saved!';
      }

      playSaveSound();

      const serverList = await fetchServerLeaderboard(10);
      renderServerLeaderboardData(serverList);

      return true;
    }

    playerNameInput?.addEventListener('input', enableSaveButtonIfReady);

    submitScoreBtn?.addEventListener('click', async () => {
      if (hasSavedThisGame) return;
      let name = (playerNameInput?.value || '').trim();
      if (!name) {
        nameHint && (nameHint.style.display = 'block');
        const ok = confirm("이름이 비어 있습니다. 'noname'으로 저장할까요?");
        if (!ok) { playerNameInput?.focus(); return; }
        name = 'noname';
        if (playerNameInput) playerNameInput.value = name;
      }

      await saveToServer(name, finalScoreValue);
    });

    playAgainBtn?.addEventListener('click', async () => {
      if (!hasSavedThisGame) {
        const wantSave = confirm("현재 점수를 저장하지 않았습니다. 저장하고 새로 시작할까요?");
        if (wantSave) {
          let name = (playerNameInput?.value || '').trim();
          if (!name) {
            const ok = confirm("이름이 비어 있습니다. 'noname'으로 저장할까요?");
            if (!ok) { playerNameInput?.focus(); return; }
            name = 'noname';
            if (playerNameInput) playerNameInput.value = name;
          }
          const saved = await saveToServer(name, finalScoreValue);
          if (!saved) return;
        }
      }
      window.location.reload();
    });

    // ─────────────────────────────────────
    // Touch controls
    // ─────────────────────────────────────
    const passiveFalse = { passive: false };
    async function onTouchStart(e) {
      e.preventDefault();
      await startAudio();
      const t = e.touches[0]; touchActive = true; touchStartX = t.clientX; touchLastX = t.clientX; passedDeadzone = false;
      if (isGrounded && !isCharging) { 
        touchMode = 'charge'; 
        isCharging = true; 
        startChargeSound();
      } else { 
        touchMode = 'drag'; 
      }
    }
    function onTouchMove(e) {
      e.preventDefault(); if (!touchActive) return;
      const t = e.touches[0]; if (touchMode === 'drag') {
        if (!passedDeadzone && Math.abs(t.clientX - touchStartX) >= DEADZONE_PX) passedDeadzone = true;
        if (passedDeadzone && !isGrounded) { const dx = t.clientX - touchLastX; player.position.x += dx * DRAG_GAIN; }
        touchLastX = t.clientX;
      }
    }
    function onTouchEnd(e) {
      e.preventDefault();
      if (touchMode === 'charge' && isCharging) {
        stopChargeSound();
        if (isGrounded) {
          velocityY = Math.max(chargeTime, MIN_JUMP);
          isGrounded = false;
          lastLandedPlatformId = null; // 점프하면 리셋
          playJumpSound();
        }
        chargeTime = 0; isCharging = false; chargeDirection = 1;
        chargeFill.style.width = '0%';
      }
      touchActive = false; touchMode = null;
    }
    renderer.domElement.addEventListener('touchstart', onTouchStart, passiveFalse);
    renderer.domElement.addEventListener('touchmove', onTouchMove, passiveFalse);
    renderer.domElement.addEventListener('touchend', onTouchEnd, passiveFalse);
    renderer.domElement.addEventListener('touchcancel', onTouchEnd, passiveFalse);

    // ─────────────────────────────────────
    // Platforms
    // ─────────────────────────────────────
    const platforms = [];
    let platformIdCounter = 0;
    
    function createPlatform(x, y, type = 'normal') {
      let width, color, special = null;
      switch (type) {
        case 'start': width = 10; color = 0x888888; break;
        case 'narrow': width = 1.2; color = 0xff4444; break;
        case 'bounce': width = 3; color = 0x4444ff; special = 'bounce'; break;
        case 'vanish': width = 3; color = 0xffff00; special = 'vanish'; break;
        case 'crumble': width = 3; color = 0xaa8866; special = 'crumble'; break;
        case 'superBounce': width = 2; color = 0xff00ff; special = 'superBounce'; break;
        default: width = 3; color = 0x00aa00;
      }
      const mat = new THREE.MeshBasicMaterial({ color, transparent: false, opacity: 1 });
      const mesh = new THREE.Mesh(new THREE.BoxGeometry(width, 0.5, 1), mat);
      mesh.position.set(x, y, 0);

      // Crumble 발판: 금간 선 추가
      if (type === 'crumble') {
        const crackMaterial = new THREE.LineBasicMaterial({ color: 0x332211, linewidth: 2 });
        const cracks = [
          [[-1.2, 0.26, 0.4], [-0.3, 0.26, -0.3]],
          [[-0.4, 0.26, 0.35], [0.5, 0.26, -0.25]],
          [[0.3, 0.26, 0.4], [1.1, 0.26, -0.2]],
          [[-0.8, 0.26, -0.1], [0.2, 0.26, 0.2]],
          [[0, 0.26, -0.35], [0.7, 0.26, 0.15]],
          [[-1.0, 0.26, 0.1], [-0.5, 0.26, -0.4]],
          [[0.6, 0.26, -0.1], [1.2, 0.26, 0.3]]
        ];
        cracks.forEach(([start, end]) => {
          const points = [new THREE.Vector3(...start), new THREE.Vector3(...end)];
          const crackGeom = new THREE.BufferGeometry().setFromPoints(points);
          const crackLine = new THREE.Line(crackGeom, crackMaterial);
          mesh.add(crackLine);
        });
      }

      // Bounce 발판: 약한 글로우 효과 추가
      if (type === 'bounce') {
        // 약한 내부 글로우
        const bounceGlow = new THREE.Mesh(
          new THREE.RingGeometry(1.0, 1.5, 32),
          new THREE.MeshBasicMaterial({
            color: 0x6666ff,
            transparent: true,
            opacity: 0.3,
            side: THREE.DoubleSide
          })
        );
        bounceGlow.rotation.x = -Math.PI / 2;
        bounceGlow.position.y = 0.28;
        mesh.add(bounceGlow);
        mesh.userData.bounceGlow = bounceGlow;
      }

      // SuperBounce 발판: 빛나는 글로우 링 추가
      if (type === 'superBounce') {
        // 내부 글로우
        const innerGlow = new THREE.Mesh(
          new THREE.RingGeometry(0.8, 1.2, 32),
          new THREE.MeshBasicMaterial({
            color: 0xff00ff,
            transparent: true,
            opacity: 0.6,
            side: THREE.DoubleSide
          })
        );
        innerGlow.rotation.x = -Math.PI / 2;
        innerGlow.position.y = 0.3;
        mesh.add(innerGlow);
        mesh.userData.innerGlow = innerGlow;

        // 외부 글로우
        const outerGlow = new THREE.Mesh(
          new THREE.RingGeometry(1.3, 1.8, 32),
          new THREE.MeshBasicMaterial({
            color: 0xff66ff,
            transparent: true,
            opacity: 0.3,
            side: THREE.DoubleSide
          })
        );
        outerGlow.rotation.x = -Math.PI / 2;
        outerGlow.position.y = 0.35;
        mesh.add(outerGlow);
        mesh.userData.outerGlow = outerGlow;

        // 파티클 효과 (작은 빛 점들)
        const sparkleGeom = new THREE.BufferGeometry();
        const sparkleCount = 8;
        const sparklePositions = new Float32Array(sparkleCount * 3);
        for (let i = 0; i < sparkleCount; i++) {
          const angle = (i / sparkleCount) * Math.PI * 2;
          sparklePositions[i * 3] = Math.cos(angle) * 0.9;
          sparklePositions[i * 3 + 1] = 0.4;
          sparklePositions[i * 3 + 2] = Math.sin(angle) * 0.9;
        }
        sparkleGeom.setAttribute('position', new THREE.BufferAttribute(sparklePositions, 3));
        const sparkleMat = new THREE.PointsMaterial({
          color: 0xffffff,
          size: 0.15,
          transparent: true,
          opacity: 0.8
        });
        const sparkles = new THREE.Points(sparkleGeom, sparkleMat);
        mesh.add(sparkles);
        mesh.userData.sparkles = sparkles;
      }

      const label = document.createElement('span');
      label.className = 'platform-label';
      platformLabelsContainer.appendChild(label);

      // 고유 ID 부여
      const platformId = platformIdCounter++;

      mesh.userData = {
        ...mesh.userData,
        id: platformId,
        type, special, originalX: x,
        amplitude: type === 'start' ? 0 : 2 + Math.random(),
        speed: type === 'start' ? 0 : 1 + Math.random(),
        phase: Math.random() * Math.PI * 2,
        prevX: x, deltaX: 0, label, vanishStarted: false, falling: false
      };
      scene.add(mesh); platforms.push(mesh);
    }

    createPlatform(0, -2, 'start');
    for (let i = 0; i < 10; i++) {
      const type = PLATFORM_TYPE_POOL[Math.floor(Math.random() * PLATFORM_TYPE_POOL.length)];
      createPlatform((Math.random() - 0.5) * 5, i * 3, type);
    }

    // ─────────────────────────────────────
    // Death plate (붉은 글로우 추가)
    // ─────────────────────────────────────
    const deathPlate = new THREE.Mesh(
      new THREE.BoxGeometry(400, 0.5, 2),
      new THREE.MeshBasicMaterial({ color: 0x000000 })
    );
    deathPlate.position.set(0, -10, 0);
    scene.add(deathPlate);

    // 붉은 글로우 레이어 1 (강한 빛)
    const deathGlow1 = new THREE.Mesh(
      new THREE.BoxGeometry(400, 0.1, 3),
      new THREE.MeshBasicMaterial({
        color: 0xff0000,
        transparent: true,
        opacity: 0.6
      })
    );
    deathGlow1.position.y = 0.3;
    deathPlate.add(deathGlow1);

    // 붉은 글로우 레이어 2 (중간 빛)
    const deathGlow2 = new THREE.Mesh(
      new THREE.BoxGeometry(400, 0.05, 5),
      new THREE.MeshBasicMaterial({
        color: 0xff3300,
        transparent: true,
        opacity: 0.4
      })
    );
    deathGlow2.position.y = 0.5;
    deathPlate.add(deathGlow2);

    // 붉은 글로우 레이어 3 (약한 빛, 넓은 범위)
    const deathGlow3 = new THREE.Mesh(
      new THREE.BoxGeometry(400, 0.03, 8),
      new THREE.MeshBasicMaterial({
        color: 0xff2200,
        transparent: true,
        opacity: 0.2
      })
    );
    deathGlow3.position.y = 0.7;
    deathPlate.add(deathGlow3);

    // 파티클 효과 (떠오르는 불꽃)
    const fireParticleCount = 50;
    const fireParticleGeom = new THREE.BufferGeometry();
    const fireParticlePositions = new Float32Array(fireParticleCount * 3);
    const fireParticleVelocities = new Float32Array(fireParticleCount);

    for (let i = 0; i < fireParticleCount; i++) {
      fireParticlePositions[i * 3] = (Math.random() - 0.5) * 20;
      fireParticlePositions[i * 3 + 1] = Math.random() * 2;
      fireParticlePositions[i * 3 + 2] = (Math.random() - 0.5) * 2;
      fireParticleVelocities[i] = 0.5 + Math.random() * 1.5;
    }
    fireParticleGeom.setAttribute('position', new THREE.BufferAttribute(fireParticlePositions, 3));
    const fireParticleMat = new THREE.PointsMaterial({
      color: 0xff4400,
      size: 0.3,
      transparent: true,
      opacity: 0.7
    });
    const fireParticles = new THREE.Points(fireParticleGeom, fireParticleMat);
    deathPlate.add(fireParticles);

    let maxY = 0;
    let nextPlatformY = 30;

    // Loop
    function animate() {
      animationId = requestAnimationFrame(animate);
      const delta = clock.getDelta();
      const elapsed = clock.getElapsedTime();

      if (Date.now() - startTime > 3000) isInvincible = false;

      // 배경 업데이트
      updateBackground(maxY, elapsed);

      // Death plate 글로우 애니메이션
      deathGlow1.material.opacity = 0.4 + Math.sin(elapsed * 4) * 0.3;
      deathGlow2.material.opacity = 0.25 + Math.sin(elapsed * 3 + 1) * 0.2;
      deathGlow3.material.opacity = 0.15 + Math.sin(elapsed * 2.5 + 2) * 0.1;

      // 불꽃 파티클 애니메이션
      const firePositions = fireParticles.geometry.attributes.position.array;
      for (let i = 0; i < fireParticleCount; i++) {
        firePositions[i * 3 + 1] += fireParticleVelocities[i] * delta;
        if (firePositions[i * 3 + 1] > 3) {
          firePositions[i * 3 + 1] = 0;
          firePositions[i * 3] = (Math.random() - 0.5) * 20;
        }
      }
      fireParticles.geometry.attributes.position.needsUpdate = true;
      fireParticleMat.opacity = 0.5 + Math.sin(elapsed * 6) * 0.3;

      platforms.forEach(p => {
        p.userData.prevX = p.position.x;
        if (p.userData.type !== 'start' && !p.userData.falling) {
          const dx = p.userData.amplitude * Math.sin(elapsed * p.userData.speed + p.userData.phase);
          p.position.x = p.userData.originalX + dx;
        }
        p.userData.deltaX = p.position.x - p.userData.prevX;

        if (p.userData.falling) {
          p.position.y -= delta * 50;
          p.material.opacity = Math.max(0, p.material.opacity - delta * 1);
          p.material.transparent = true;
        }

        // SuperBounce 글로우 애니메이션
        if (p.userData.innerGlow) {
          p.userData.innerGlow.material.opacity = 0.4 + Math.sin(elapsed * 5) * 0.3;
          p.userData.innerGlow.rotation.z = elapsed * 2;
        }
        if (p.userData.outerGlow) {
          p.userData.outerGlow.material.opacity = 0.2 + Math.sin(elapsed * 3 + 1) * 0.15;
          p.userData.outerGlow.scale.setScalar(1 + Math.sin(elapsed * 4) * 0.1);
          p.userData.outerGlow.rotation.z = -elapsed * 1.5;
        }
        if (p.userData.sparkles) {
          p.userData.sparkles.material.opacity = 0.5 + Math.sin(elapsed * 8) * 0.4;
          p.userData.sparkles.rotation.y = elapsed * 3;
        }

        // Bounce 글로우 애니메이션 (약하게)
        if (p.userData.bounceGlow) {
          p.userData.bounceGlow.material.opacity = 0.2 + Math.sin(elapsed * 3) * 0.15;
          p.userData.bounceGlow.scale.setScalar(1 + Math.sin(elapsed * 2) * 0.05);
        }

        const label = p.userData.label;
        if (label && label.style.display !== 'none') {
          const pos = p.position.clone().project(camera);
          label.style.left = `${(pos.x + 1) / 2 * window.innerWidth}px`;
          label.style.top = `${(-pos.y + 1) / 2 * window.innerHeight}px`;
        }
      });

      if (isCharging && isGrounded) {
        chargeTime += chargeDirection * delta * chargeSpeed;
        if (chargeTime >= maxCharge) { chargeTime = maxCharge; chargeDirection = -1; }
        else if (chargeTime <= 0) { chargeTime = 0; chargeDirection = 1; }
        chargeFill.style.width = `${(chargeTime / maxCharge) * 100}%`;
        updateChargeSound(chargeTime / maxCharge);
      }

      if (!isGrounded) {
        if (input.left) player.position.x -= 0.1;
        if (input.right) player.position.x += 0.1;
      }

      velocityY += (velocityY > 0) ? -0.02 : -0.006;
      player.position.y += velocityY;

      if (isGrounded && onPlatform) player.position.x += onPlatform.userData.deltaX;

      onPlatform = null; isGrounded = false;

      for (let i = platforms.length - 1; i >= 0; i--) {
        const p = platforms[i];
        const w = p.geometry.parameters.width;
        const playerBottomPrev = player.position.y - velocityY - 0.5;
        const playerBottomNow = player.position.y - 0.5;
        const platformTop = p.position.y + 0.25;
        const withinX = Math.abs(player.position.x - p.position.x) < (w / 2 + 0.5);
        const falling = velocityY <= 0;
        const crossed = playerBottomPrev >= platformTop && playerBottomNow <= platformTop;

        if (withinX && crossed && falling && !p.userData.falling) {
          player.position.y = platformTop + 0.5;
          velocityY = 0; isGrounded = true; onPlatform = p;

          // 같은 발판에 이미 착지한 적 있으면 소리 안냄
          const isNewLanding = lastLandedPlatformId !== p.userData.id;
          lastLandedPlatformId = p.userData.id;

          if (isNewLanding) {
            if (p.userData.special === 'bounce') {
              velocityY = maxCharge;
              isGrounded = false;
              lastLandedPlatformId = null;
              playBounceSound();
            } else if (p.userData.special === 'superBounce') {
              velocityY = maxCharge * 1.4;
              isGrounded = false;
              lastLandedPlatformId = null;
              playSuperBounceSound();
            } else if (p.userData.special === 'crumble') {
              playCrumbleSound();
              // 1초 후 부서짐 시작
              setTimeout(() => {
                p.userData.falling = true;
                p.material.transparent = true;
              }, 1000);
            }
            // 일반 착지음 제거됨
          }

          if (p.userData.special === 'vanish' && !p.userData.vanishStarted) {
            p.userData.vanishStarted = true;
            const label = p.userData.label;
            let seconds = 3;
            if (label) { label.style.display = 'block'; label.innerText = seconds; }
            const interval = setInterval(() => {
              seconds--;
              if (seconds <= 0) {
                clearInterval(interval);
                label?.remove?.();
                p.userData.falling = true;
                p.material.transparent = true;
              } else if (label) { label.innerText = seconds; }
            }, 1000);
          }
          break;
        }
      }

      if (player.position.y > camera.position.y - 3) camera.position.y = player.position.y + 3;
      if (player.position.y > maxY) maxY = player.position.y;
      scoreEl.innerText = `Score: ${Math.floor(maxY)}`;

      while (nextPlatformY < maxY + 30) {
        const type = PLATFORM_TYPE_POOL[Math.floor(Math.random() * PLATFORM_TYPE_POOL.length)];
        createPlatform((Math.random() - 0.5) * 5, nextPlatformY, type);

        const a = 0.002, b = 2000;
        const difficultyScale = 1 / (1 + Math.exp(-a * (maxY - b)));
        const baseGap = 3, maxGap = 6;
        const gap = baseGap + (maxGap - baseGap) * difficultyScale;
        const baseJitter = 0.2, maxJitter = 2.0;
        const jitter = baseJitter + (maxJitter - baseJitter) * difficultyScale;
        nextPlatformY += gap + (Math.random() * 2 - 1) * jitter;
      }

      deathPlate.position.y += delta * 1.5;
      if (player.position.y - deathPlate.position.y > 25) deathPlate.position.y = player.position.y - 20;

      const plateTop = deathPlate.position.y + 0.25;
      const playerBottom = player.position.y - 0.5;
      const withinPlateX = Math.abs(player.position.x - deathPlate.position.x) < 5;
      const lowestY = platforms.reduce((min, p) => Math.min(min, p.position.y), Infinity);
      const fellTooLow = player.position.y < lowestY - 5;
      const hitDeathPlate = !isInvincible && playerBottom <= plateTop && withinPlateX;

      if (fellTooLow || hitDeathPlate) {
        const score = Math.floor(maxY);
        finalScoreText.innerText = `Your Score: ${score}`;
        gameOverScreen.style.display = 'block';

        stopChargeSound();
        playGameOverSound();

        finalScoreValue = score;

        (async () => {
          const serverData = await fetchServerLeaderboard(10);
          if (!renderServerLeaderboardData(serverData)) {
            leaderboardList.innerHTML = '<li style="color:#ff6666;">서버 연결 실패</li>';
          }
        })();

        playerNameInput && setTimeout(() => playerNameInput.focus(), 0);
        enableSaveButtonIfReady();

        cancelAnimationFrame(animationId);
        return;
      }

      for (let i = platforms.length - 1; i >= 0; i--) {
        const p = platforms[i];
        if (p.position.y < camera.position.y - 40) {
          p.userData.label?.remove?.();
          scene.remove(p);
          platforms.splice(i, 1);
        }
      }

      renderer.render(scene, camera);
    }

    animate();
  </script>
</body>

</html>
