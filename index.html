<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Wave Charged Jump Game (v1.5)</title>
  <style>
    html, body { height: 100%; touch-action: none; }
    body { margin: 0; overflow: hidden; }
    canvas { display: block; }

    #score {
      position: absolute; top: 10px; left: 10px;
      font-size: 24px; background: rgba(255,255,255,0.7);
      padding: 6px 10px; border-radius: 8px; z-index: 10;
      user-select: none;
    }

    #chargeBar {
      position: absolute; bottom: 10px; left: 50%;
      transform: translateX(-50%); width: min(80vw, 800px); height: 20px;
      background: #ddd; border-radius: 10px; overflow: hidden; z-index: 11;
    }
    #chargeFill { height: 100%; background: red; width: 0%; }

    #gameOverScreen {
      position: absolute; top: 50%; left: 50%;
      transform: translate(-50%, -50%); background: rgba(0,0,0,0.8);
      color: white; padding: 30px; border-radius: 12px;
      display: none; text-align: center; z-index: 20; min-width: 320px;
    }

    #platformLabelsContainer { position: absolute; top: 0; left: 0; pointer-events: none; z-index: 15; }
    .platform-label { position: absolute; font-size: 20px; font-weight: bold; color: black;
      text-shadow: 1px 1px white; transform: translate(-50%, -50%); display: none; }
  </style>
</head>
<body>
  <div id="score">Score: 0</div>
  <div id="chargeBar"><div id="chargeFill"></div></div>

  <!-- Game Over + Leaderboard UI -->
  <div id="gameOverScreen">
    <h1>Game Over</h1>
    <p id="finalScoreText"></p>
    <p id="highScoreText"></p>

    <div style="margin-top:12px;">
      <input id="playerNameInput" type="text" maxlength="24"
             placeholder="Your name" style="padding:8px;border-radius:6px;border:1px solid #ccc;width:220px;">
      <button id="submitScoreBtn" disabled
              style="padding:8px 12px;border-radius:6px;border:0;background:#4CAF50;color:#fff;cursor:pointer;opacity:0.6;">
        Save Score
      </button>
      <div id="nameHint" style="margin-top:6px;font-size:12px;color:#ffb300;display:none;">
        이름이 없으면 ‘noname’으로 저장할지 확인합니다.
      </div>
    </div>

    <div style="margin-top:10px;">
      <button id="playAgainBtn">Play Again</button>
    </div>

    <div id="leaderboard" style="margin-top:18px;text-align:left;max-width:360px;margin-left:auto;margin-right:auto;">
      <h2 style="margin:6px 0 8px;">Leaderboard</h2>
      <ol id="leaderboardList" style="padding-left:18px;margin:0;"></ol>
      <div style="margin-top:10px;">
        <button id="clearScoresBtn" style="padding:6px 10px;border-radius:6px;border:1px solid #999;background:#222;color:#fff;cursor:pointer;">
          Clear Local Scores
        </button>
      </div>
    </div>
  </div>

  <div id="platformLabelsContainer"></div>

  <script type="module">
    import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.module.js';

    const PLATFORM_TYPE_POOL = ['normal','normal','normal','normal','normal','narrow','narrow','narrow','bounce','bounce','vanish'];

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xd0f0ff);

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 5, 10);
    camera.lookAt(0, 0, 0);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    document.body.appendChild(renderer.domElement);

    window.addEventListener('resize', () => {
      const w = window.innerWidth, h = window.innerHeight;
      renderer.setSize(w, h);
      camera.aspect = w / h;
      camera.updateProjectionMatrix();
    });

    const clock = new THREE.Clock();
    let animationId;

    // ─────────────────────────────────────
    // UI
    // ─────────────────────────────────────
    const scoreEl = document.getElementById('score');
    const chargeFill = document.getElementById('chargeFill');
    const finalScoreText = document.getElementById('finalScoreText');
    const highScoreText = document.getElementById('highScoreText');
    const gameOverScreen = document.getElementById('gameOverScreen');
    const platformLabelsContainer = document.getElementById('platformLabelsContainer');
    const playerNameInput = document.getElementById('playerNameInput');
    const submitScoreBtn  = document.getElementById('submitScoreBtn');
    const playAgainBtn    = document.getElementById('playAgainBtn');
    const leaderboardList = document.getElementById('leaderboardList');
    const clearScoresBtn  = document.getElementById('clearScoresBtn');
    const nameHint        = document.getElementById('nameHint');

    // ─────────────────────────────────────
    // 서버 API 연결 (로컬/배포 자동 분기)
    // ─────────────────────────────────────
    const API_BASE =
      (location.hostname === 'localhost' || location.hostname === '127.0.0.1')
        ? 'http://localhost:8080'
        : 'https://wave-charged-jump-game.onrender.com'; // ← 배포 서버 시 주소로 교체

    async function postServerScore(name, score) {
      try {
        const res = await fetch(`${API_BASE}/api/scores`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ name, score })
        });
        if (!res.ok) throw new Error('post failed');
        return await res.json();
      } catch (e) {
        console.warn('server score post failed:', e);
        return null;
      }
    }

    async function fetchServerLeaderboard(limit = 20) {
      try {
        const res = await fetch(`${API_BASE}/api/scores/top?limit=${limit}`, { method: 'GET' });
        if (!res.ok) throw new Error('fetch failed');
        return await res.json(); // { items:[{rank,name,score,createdAt,id}, ...] }
      } catch (e) {
        console.warn('server leaderboard fetch failed:', e);
        return null;
      }
    }

    function renderServerLeaderboardData(data) {
      if (!data || !Array.isArray(data.items)) return false;
      leaderboardList.innerHTML = '';
      data.items.forEach(item => {
        const li = document.createElement('li');
        li.textContent = `#${item.rank} ${item.name} — ${item.score}`;
        leaderboardList.appendChild(li);
      });
      return true;
    }

    // ─────────────────────────────────────
    // Game state
    // ─────────────────────────────────────
    const startTime = Date.now();
    let isInvincible = true;
    let highScore = parseInt(localStorage.getItem('highScore') || '0', 10);
    let velocityY = 0, isGrounded = false, onPlatform = null;
    let chargeTime = 0, isCharging = false, chargeDirection = 1;
    const maxCharge = 1.0, chargeSpeed = 0.8;
    let touchActive = false, touchMode = null, touchStartX = 0, touchLastX = 0, passedDeadzone = false;
    const DRAG_GAIN = 0.01, DEADZONE_PX = 8, MIN_JUMP = 0.2;

    // 저장 흐름 상태 / 최종 점수 캐시
    let hasSavedThisGame = false;
    let finalScoreValue = 0;

    // Player
    const player = new THREE.Mesh(
      new THREE.BoxGeometry(1, 1, 1),
      new THREE.MeshBasicMaterial({ color: 0x0000ff })
    );
    scene.add(player);
    player.position.y = 0;

    // Keyboard
    const input = { left: false, right: false };
    document.addEventListener('keydown', e => {
      if (e.code === 'KeyA' || e.code === 'ArrowLeft') input.left = true;
      if (e.code === 'KeyD' || e.code === 'ArrowRight') input.right = true;
      if (e.code === 'Space' && isGrounded) isCharging = true;
    });
    document.addEventListener('keyup', e => {
      if (e.code === 'KeyA' || e.code === 'ArrowLeft') input.left = false;
      if (e.code === 'KeyD' || e.code === 'ArrowRight') input.right = false;
      if (e.code === 'Space' && isGrounded && isCharging) {
        velocityY = Math.max(chargeTime, MIN_JUMP);
        chargeTime = 0; isCharging = false; chargeDirection = 1; isGrounded = false;
        chargeFill.style.width = '0%';
      }
    });

    // ─────────────────────────────────────
    // Local leaderboard (fallback)
    // ─────────────────────────────────────
    const LB_STORAGE_KEY = 'wcjg_leaderboard_v1';
    const LAST_NAME_KEY  = 'wcjg_last_name';

    function loadLeaderboard() {
      try { return JSON.parse(localStorage.getItem(LB_STORAGE_KEY) || '[]'); }
      catch { return []; }
    }
    function saveLeaderboard(entries) {
      localStorage.setItem(LB_STORAGE_KEY, JSON.stringify(entries));
    }
    function recordScore(name, score) {
      const clean = (name || '').trim() || 'Anonymous';
      localStorage.setItem(LAST_NAME_KEY, clean);
      const now = new Date().toISOString();
      const list = loadLeaderboard();

      const map = new Map();
      for (const e of list) {
        const prev = map.get(e.name);
        if (!prev || e.score > prev.score) map.set(e.name, e);
        else if (e.score === prev.score && e.date > prev.date) map.set(e.name, e);
      }
      const prev = map.get(clean);
      if (!prev || score > prev.score) map.set(clean, { name: clean, score, date: now });
      else if (score === prev?.score)   map.set(clean, { name: clean, score, date: now });

      const arr = [...map.values()].sort((a,b) => b.score - a.score || (b.date > a.date ? 1 : -1)).slice(0, 20);
      saveLeaderboard(arr);
      return arr;
    }
    function renderLeaderboard() {
      const list = loadLeaderboard().sort((a,b) => b.score - a.score || (b.date > a.date ? 1 : -1));
      leaderboardList.innerHTML = '';
      list.forEach(e => {
        const li = document.createElement('li');
        li.textContent = `${e.name} — ${e.score}`; // <ol>이 번호 자동 부여
        leaderboardList.appendChild(li);
      });
    }
    (function presetName(){
      const last = localStorage.getItem(LAST_NAME_KEY);
      if (playerNameInput && last) playerNameInput.value = last;
    })();

    function enableSaveButtonIfReady() {
      const hasName = !!(playerNameInput?.value.trim());
      if (submitScoreBtn) {
        submitScoreBtn.disabled = !hasName || hasSavedThisGame;
        submitScoreBtn.style.opacity = submitScoreBtn.disabled ? '0.6' : '1';
      }
    }

    function saveCurrentRun(name, score) {
      if (hasSavedThisGame) return;
      recordScore(name, score);
      renderLeaderboard();
      hasSavedThisGame = true;
      if (submitScoreBtn) { submitScoreBtn.disabled = true; submitScoreBtn.textContent = 'Saved!'; }
      enableSaveButtonIfReady();
    }

    // 이름 입력 변화 → 버튼 활성화만
    playerNameInput?.addEventListener('input', enableSaveButtonIfReady);

    // Save 버튼: 이름 없으면 noname 확인 → 로컬 저장 → 서버 저장 → 서버 랭킹 새로고침
    submitScoreBtn?.addEventListener('click', async () => {
      if (hasSavedThisGame) return;
      let name = (playerNameInput?.value || '').trim();
      if (!name) {
        nameHint && (nameHint.style.display = 'block');
        const ok = confirm("이름이 비어 있습니다. 'noname'으로 저장할까요?");
        if (!ok) { playerNameInput?.focus(); return; }
        name = 'noname';
        if (playerNameInput) playerNameInput.value = name;
      }

      // 1) 로컬 저장
      saveCurrentRun(name, finalScoreValue);

      // 2) 서버 저장 (실패해도 흐름 유지)
      await postServerScore(name, finalScoreValue);

      // 3) 서버 랭킹 로드 시도 (성공 시 서버 랭킹으로 교체, 실패 시 로컬 유지)
      const serverList = await fetchServerLeaderboard(20);
      if (!renderServerLeaderboardData(serverList)) {
        console.log('Server leaderboard unavailable. Showing local leaderboard.');
      }
    });

    // Play Again: 저장 안 했으면 먼저 물어보기
    playAgainBtn?.addEventListener('click', () => {
      if (!hasSavedThisGame) {
        const wantSave = confirm("현재 점수를 저장하지 않았습니다. 저장하고 새로 시작할까요?");
        if (wantSave) {
          let name = (playerNameInput?.value || '').trim();
          if (!name) {
            const ok = confirm("이름이 비어 있습니다. 'noname'으로 저장할까요?");
            if (!ok) { playerNameInput?.focus(); return; }
            name = 'noname';
            if (playerNameInput) playerNameInput.value = name;
          }
          saveCurrentRun(name, finalScoreValue);
        }
      }
      window.location.reload();
    });

    clearScoresBtn?.addEventListener('click', () => {
      if (confirm('Delete all local scores?')) { saveLeaderboard([]); renderLeaderboard(); }
    });

    // ─────────────────────────────────────
    // Touch controls
    // ─────────────────────────────────────
    const passiveFalse = { passive: false };
    function onTouchStart(e){ e.preventDefault();
      const t = e.touches[0]; touchActive = true; touchStartX = t.clientX; touchLastX = t.clientX; passedDeadzone = false;
      if (isGrounded) { touchMode='charge'; isCharging=true; } else { touchMode='drag'; }
    }
    function onTouchMove(e){ e.preventDefault(); if (!touchActive) return;
      const t=e.touches[0]; if (touchMode==='drag'){
        if (!passedDeadzone && Math.abs(t.clientX-touchStartX)>=DEADZONE_PX) passedDeadzone=true;
        if (passedDeadzone && !isGrounded){ const dx=t.clientX-touchLastX; player.position.x += dx*DRAG_GAIN; }
        touchLastX=t.clientX;
      }}
    function onTouchEnd(e){ e.preventDefault();
      if (touchMode==='charge' && isGrounded && isCharging){
        velocityY = Math.max(chargeTime, MIN_JUMP);
        chargeTime=0; isCharging=false; chargeDirection=1; isGrounded=false;
        chargeFill.style.width='0%';
      }
      touchActive=false; touchMode=null;
    }
    renderer.domElement.addEventListener('touchstart', onTouchStart, passiveFalse);
    renderer.domElement.addEventListener('touchmove',  onTouchMove,  passiveFalse);
    renderer.domElement.addEventListener('touchend',   onTouchEnd,   passiveFalse);
    renderer.domElement.addEventListener('touchcancel',onTouchEnd,   passiveFalse);

    // ─────────────────────────────────────
    // Platforms
    // ─────────────────────────────────────
    const platforms = [];
    function createPlatform(x, y, type='normal') {
      let width, color, special=null;
      switch (type) {
        case 'start':  width=10;  color=0x888888; break;
        case 'narrow': width=1.2; color=0xff4444; break;
        case 'bounce': width=3;   color=0x4444ff; special='bounce'; break;
        case 'vanish': width=3;   color=0xffff00; special='vanish'; break;
        default:       width=3;   color=0x00aa00;
      }
      const mat = new THREE.MeshBasicMaterial({ color, transparent:false, opacity:1 });
      const mesh= new THREE.Mesh(new THREE.BoxGeometry(width,0.5,1), mat);
      mesh.position.set(x,y,0);

      const label = document.createElement('span');
      label.className = 'platform-label';
      platformLabelsContainer.appendChild(label);

      mesh.userData = {
        type, special, originalX:x,
        amplitude: type==='start'?0:2+Math.random(),
        speed:     type==='start'?0:1+Math.random(),
        phase: Math.random()*Math.PI*2,
        prevX:x, deltaX:0, label, vanishStarted:false, falling:false
      };
      scene.add(mesh); platforms.push(mesh);
    }

    // Initial platforms
    createPlatform(0, -2, 'start');
    for (let i=0;i<10;i++){
      const type = PLATFORM_TYPE_POOL[Math.floor(Math.random()*PLATFORM_TYPE_POOL.length)];
      createPlatform((Math.random()-0.5)*5, i*3, type);
    }

    // Death plate
    const deathPlate = new THREE.Mesh(
      new THREE.BoxGeometry(400, 0.5, 2),
      new THREE.MeshBasicMaterial({ color: 0x000000 })
    );
    deathPlate.position.set(0, -10, 0);
    scene.add(deathPlate);

    // Score/camera
    let maxY = 0;
    let nextPlatformY = 30;

    // Loop
    function animate() {
      animationId = requestAnimationFrame(animate);
      const delta = clock.getDelta();
      const elapsed = clock.getElapsedTime();

      if (Date.now() - startTime > 3000) isInvincible = false;

      platforms.forEach(p => {
        p.userData.prevX = p.position.x;
        if (p.userData.type!=='start' && !p.userData.falling) {
          const dx = p.userData.amplitude * Math.sin(elapsed * p.userData.speed + p.userData.phase);
          p.position.x = p.userData.originalX + dx;
        }
        p.userData.deltaX = p.position.x - p.userData.prevX;

        if (p.userData.falling) {
          p.position.y -= delta * 50;
          p.material.opacity = Math.max(0, p.material.opacity - delta * 1);
          p.material.transparent = true;
        }

        const label = p.userData.label;
        if (label && label.style.display !== 'none') {
          const pos = p.position.clone().project(camera);
          label.style.left = `${(pos.x + 1) / 2 * window.innerWidth}px`;
          label.style.top  = `${(-pos.y + 1) / 2 * window.innerHeight}px`;
        }
      });

      if (isCharging && isGrounded) {
        chargeTime += chargeDirection * delta * chargeSpeed;
        if (chargeTime >= maxCharge) { chargeTime=maxCharge; chargeDirection=-1; }
        else if (chargeTime <= 0)    { chargeTime=0;        chargeDirection= 1; }
        chargeFill.style.width = `${(chargeTime / maxCharge) * 100}%`;
      }

      if (!isGrounded) {
        if (input.left)  player.position.x -= 0.1;
        if (input.right) player.position.x += 0.1;
      }

      velocityY += (velocityY > 0) ? -0.02 : -0.006;
      player.position.y += velocityY;

      if (isGrounded && onPlatform) player.position.x += onPlatform.userData.deltaX;

      onPlatform = null; isGrounded = false;

      for (let i = platforms.length - 1; i >= 0; i--) {
        const p = platforms[i];
        const w = p.geometry.parameters.width;
        const playerBottomPrev = player.position.y - velocityY - 0.5;
        const playerBottomNow  = player.position.y - 0.5;
        const platformTop = p.position.y + 0.25;
        const withinX = Math.abs(player.position.x - p.position.x) < (w / 2 + 0.5);
        const falling = velocityY <= 0;
        const crossed = playerBottomPrev >= platformTop && playerBottomNow <= platformTop;

        if (withinX && crossed && falling && !p.userData.falling) {
          player.position.y = platformTop + 0.5;
          velocityY = 0; isGrounded = true; onPlatform = p;

          if (p.userData.special === 'bounce') { velocityY = maxCharge; isGrounded = false; }

          if (p.userData.special === 'vanish' && !p.userData.vanishStarted) {
            p.userData.vanishStarted = true;
            const label = p.userData.label;
            let seconds = 3;
            if (label) { label.style.display = 'block'; label.innerText = seconds; }
            const interval = setInterval(() => {
              seconds--;
              if (seconds <= 0) {
                clearInterval(interval);
                label?.remove?.();
                p.userData.falling = true;
                p.material.transparent = true;
              } else if (label) { label.innerText = seconds; }
            }, 1000);
          }
          break;
        }
      }

      if (player.position.y > camera.position.y - 3) camera.position.y = player.position.y + 3;
      if (player.position.y > maxY) maxY = player.position.y;
      scoreEl.innerText = `Score: ${Math.floor(maxY)}`;

      while (nextPlatformY < maxY + 30) {
        const type = PLATFORM_TYPE_POOL[Math.floor(Math.random() * PLATFORM_TYPE_POOL.length)];
        createPlatform((Math.random()-0.5)*5, nextPlatformY, type);

        const a=0.002, b=2000;
        const difficultyScale = 1 / (1 + Math.exp(-a * (maxY - b)));
        const baseGap=3, maxGap=6;
        const gap = baseGap + (maxGap - baseGap) * difficultyScale;
        const baseJitter=0.2, maxJitter=2.0;
        const jitter = baseJitter + (maxJitter - baseJitter) * difficultyScale;
        nextPlatformY += gap + (Math.random()*2 - 1) * jitter;
      }

      deathPlate.position.y += delta * 1.5;
      if (player.position.y - deathPlate.position.y > 25) deathPlate.position.y = player.position.y - 20;

      const plateTop = deathPlate.position.y + 0.25;
      const playerBottom = player.position.y - 0.5;
      const withinPlateX = Math.abs(player.position.x - deathPlate.position.x) < 5;
      const lowestY = platforms.reduce((min, p) => Math.min(min, p.position.y), Infinity);
      const fellTooLow = player.position.y < lowestY - 5;
      const hitDeathPlate = !isInvincible && playerBottom <= plateTop && withinPlateX;

      if (fellTooLow || hitDeathPlate) {
        const score = Math.floor(maxY);
        if (score > highScore) { highScore = score; localStorage.setItem('highScore', String(highScore)); }
        finalScoreText.innerText = `Your Score: ${score}`;
        highScoreText.innerText = `High Score: ${highScore}`;
        gameOverScreen.style.display = 'block';

        // 최종 점수 캐싱
        finalScoreValue = score;

        // 서버 랭킹 먼저 시도 → 실패 시 로컬로 폴백
        (async () => {
          const serverData = await fetchServerLeaderboard(20);
          if (!renderServerLeaderboardData(serverData)) {
            renderLeaderboard();
          }
        })();

        (playerNameInput) && setTimeout(() => playerNameInput.focus(), 0);
        enableSaveButtonIfReady();

        cancelAnimationFrame(animationId);
        return;
      }

      for (let i = platforms.length - 1; i >= 0; i--) {
        const p = platforms[i];
        if (p.position.y < camera.position.y - 40) {
          p.userData.label?.remove?.();
          scene.remove(p);
          platforms.splice(i, 1);
        }
      }

      renderer.render(scene, camera);
    }

    animate();
  </script>
</body>
</html>
